<!-- floorproject/administrator/templates/administrator/edit_plans.html -->
{% extends 'administrator/base.html' %}
{% load static %}

{% block title %}Édition des Plans{% endblock %}

{% block css %}
<style>
    html, body {
        height: 100%;
        margin: 0;
    }
    .leaflet-container {
        height: 400px;
        width: 100%;
        max-width: 100%;
        max-height: 100%;
    }
    .edit-panel {
        background-color: #f8f9fa;
        padding: 15px;
        border-radius: 5px;
        margin-bottom: 20px;
    }
    .tab-pane {
        padding: 15px;
    }
    .form-group {
        margin-bottom: 15px;
    }
    .icon-preview {
        width: 40px;
        height: 40px;
    }
    .plan-preview {
        max-width: 100px;
        max-height: 100px;
        object-fit: contain;
    }
    .list-group-item {
        cursor: pointer;
    }
    .list-group-item:hover {
        background-color: #f5f5f5;
    }
    .active-item {
        background-color: #e9ecef;
    }
    .drag-handle {
        cursor: move;
        padding: 5px;
    }
    #plansOrderList .list-group-item {
        display: flex;
        align-items: center;
    }
    .plan-preview-container {
        width: 100px;
        margin-right: 10px;
    }
</style>
{% endblock %}

{% block content %}
<div class="container-fluid">
    <h2 class="mb-4">Édition des Plans</h2>

    <!-- Carte pour visualiser et interagir -->
    <div class="row mb-4">
        <div class="col-md-12">
            <div id="map" style="width: 50%; height: 500px;" class="leaflet-container"></div>
        </div>
    </div>

    <!-- Panel d'édition -->
    <div class="row" style="width: 50%; height: 500px;">
        <div class="col-md-12">
            <ul class="nav nav-tabs" id="editionTabs" role="tablist">
                <li class="nav-item" role="presentation">
                    <button class="nav-link active" id="settings-tab" data-bs-toggle="tab" data-bs-target="#settings" type="button" role="tab" aria-controls="settings" aria-selected="true">Paramètres</button>
                </li>
                <li class="nav-item" role="presentation">
                    <button class="nav-link" id="plans-tab" data-bs-toggle="tab" data-bs-target="#plans" type="button" role="tab" aria-controls="plans" aria-selected="false">Plans</button>
                </li>
                <li class="nav-item" role="presentation">
                    <button class="nav-link" id="icons-tab" data-bs-toggle="tab" data-bs-target="#icons" type="button" role="tab" aria-controls="icons" aria-selected="false">Icônes</button>
                </li>
                <li class="nav-item" role="presentation">
                    <button class="nav-link" id="markers-tab" data-bs-toggle="tab" data-bs-target="#markers" type="button" role="tab" aria-controls="markers" aria-selected="false">Marqueurs</button>
                </li>
            </ul>

            <div class="tab-content" id="editionTabsContent">
                <!-- Onglet Paramètres (bounds et map) -->
                <div class="tab-pane fade show active" id="settings" role="tabpanel" aria-labelledby="settings-tab">
                    <form id="settingsForm" class="row">
                        <div class="col-md-6">
                            <h4>Limites de la carte (bounds)</h4>
                            <div class="form-group">
                                <label for="minX">X Min:</label>
                                <input type="number" class="form-control" id="minX" required>
                            </div>
                            <div class="form-group">
                                <label for="minY">Y Min:</label>
                                <input type="number" class="form-control" id="minY" required>
                            </div>
                            <div class="form-group">
                                <label for="maxX">X Max:</label>
                                <input type="number" class="form-control" id="maxX" required>
                            </div>
                            <div class="form-group">
                                <label for="maxY">Y Max:</label>
                                <input type="number" class="form-control" id="maxY" required>
                            </div>
                        </div>

                        <div class="col-md-6">
                            <h4>Paramètres de la carte (map)</h4>
                            <div class="form-group">
                                <label for="minZoom">Zoom Minimum:</label>
                                <input type="number" step="0.5" class="form-control" id="minZoom" required>
                            </div>
                            <div class="form-group">
                                <label for="zoomDelta">Delta de Zoom:</label>
                                <input type="number" step="0.05" class="form-control" id="zoomDelta" required>
                            </div>
                            <div class="form-group">
                                <label for="zoomSnap">Snap de Zoom:</label>
                                <input type="number" step="0.05" class="form-control" id="zoomSnap" required>
                            </div>
                            <div class="form-group">
                                <label for="defaultLayer">Couche par défaut:</label>
                                <select class="form-control" id="defaultLayer">
                                    <option value="">Sélectionnez un plan...</option>
                                    <!-- Les plans seront ajoutés ici dynamiquement -->
                                </select>
                            </div>
                            <div class="form-group">
                                <label for="centerX">Centre X:</label>
                                <input type="number" class="form-control" id="centerX" required>
                            </div>
                            <div class="form-group">
                                <label for="centerY">Centre Y:</label>
                                <input type="number" class="form-control" id="centerY" required>
                            </div>
                            <div class="form-group">
                                <label for="defaultZoom">Zoom par défaut:</label>
                                <input type="number" step="0.5" class="form-control" id="defaultZoom" required>
                            </div>
                        </div>

                        <div class="col-12 mt-3">
                            <button type="submit" class="btn btn-primary">Enregistrer</button>
                            <button type="button" id="useCurrentBounds" class="btn btn-secondary">Utiliser Limites Actuelles</button>
                        </div>
                    </form>
                </div>

                <!-- Onglet Plans -->
                <div class="tab-pane fade" id="plans" role="tabpanel" aria-labelledby="plans-tab">
                    <div class="row">
                        <div class="col-md-6">
                            <div class="d-flex justify-content-between mb-3">
                                <h4>Liste des Plans</h4>
                                <button class="btn btn-sm btn-success" id="newPlanBtn">Nouveau Plan</button>
                            </div>

                            <div class="list-group mb-3" id="plansList">
                                <!-- Les plans seront ajoutés ici dynamiquement -->
                            </div>
                        </div>

                        <div class="col-md-6">
                            <form id="planForm" style="display: none;">
                                <h5 id="planFormTitle">Ajouter un Plan</h5>
                                <div class="form-group">
                                    <label for="planId">ID du Plan:</label>
                                    <input type="text" class="form-control" id="planId" required>
                                    <small class="form-text text-muted" id="planIdFeedback"></small>
                                </div>
                                <div class="form-group">
                                    <label for="planName">Nom du Plan:</label>
                                    <input type="text" class="form-control" id="planName" required>
                                </div>
                                <div class="form-group">
                                    <label for="planImage">Image du Plan:</label>
                                    <select class="form-control" id="planImage" required>
                                        <option value="">Sélectionnez une image...</option>
                                        {% for file in plan_files %}
                                            <option value="{{ file }}">{{ file }}</option>
                                        {% endfor %}
                                    </select>
                                </div>
                                <input type="hidden" id="planAction" value="create">
                                <input type="hidden" id="originalPlanId" value="">
                                <button type="submit" class="btn btn-primary">Enregistrer</button>
                                <button type="button" id="cancelPlanBtn" class="btn btn-secondary">Annuler</button>
                                <button type="button" id="deletePlanBtn" class="btn btn-danger" style="display: none;">Supprimer</button>
                            </form>

                            <div id="planOrderContainer" class="mt-4">
                                <h5>Ordre des Plans</h5>
                                <p class="text-muted">Glissez-déposez pour changer l'ordre</p>
                                <div class="list-group" id="plansOrderList">
                                    <!-- Les plans seront ajoutés ici dynamiquement pour être réordonnés -->
                                </div>
                                <button type="button" id="saveOrderBtn" class="btn btn-primary mt-3">Enregistrer l'Ordre</button>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Onglet Icônes -->
                <div class="tab-pane fade" id="icons" role="tabpanel" aria-labelledby="icons-tab">
                    <div class="row">
                        <div class="col-md-6">
                            <div class="d-flex justify-content-between mb-3">
                                <h4>Liste des Icônes</h4>
                                <button class="btn btn-sm btn-success" id="newIconBtn">Nouvelle Icône</button>
                            </div>

                            <div class="list-group mb-3" id="iconsList">
                                <!-- Les icônes seront ajoutées ici dynamiquement -->
                            </div>
                        </div>

                        <div class="col-md-6">
                            <form id="iconForm" style="display: none;">
                                <h5 id="iconFormTitle">Ajouter une Icône</h5>
                                <div class="form-group">
                                    <label for="iconName">Nom de l'Icône:</label>
                                    <input type="text" class="form-control" id="iconName" required>
                                    <small class="form-text text-muted" id="iconNameFeedback"></small>
                                </div>
                                <div class="form-group">
                                    <label for="iconUrl">URL de l'Icône:</label>
                                    <select class="form-control" id="iconUrl" required>
                                        <option value="">Sélectionnez une icône...</option>
                                        {% for file in marker_files %}
                                            <option value="{{ file }}">{{ file }}</option>
                                        {% endfor %}
                                    </select>
                                </div>
                                <div class="form-group">
                                    <label for="shadowUrl">URL de l'Ombre:</label>
                                    <select class="form-control" id="shadowUrl">
                                        <option value="">Aucune ombre</option>
                                        {% for file in marker_files %}
                                            <option value="{{ file }}">{{ file }}</option>
                                        {% endfor %}
                                    </select>
                                </div>
                                <div class="form-group">
                                    <label for="iconSize">Taille de l'Icône [largeur, hauteur]:</label>
                                    <input type="text" class="form-control" id="iconSize" placeholder="Ex: [25, 41]">
                                </div>
                                <div class="form-group">
                                    <label for="iconAnchor">Ancre de l'Icône [x, y]:</label>
                                    <input type="text" class="form-control" id="iconAnchor" placeholder="Ex: [12, 41]">
                                </div>
                                <div class="form-group">
                                    <label for="popupAnchor">Ancre du Popup [x, y]:</label>
                                    <input type="text" class="form-control" id="popupAnchor" placeholder="Ex: [1, -34]">
                                </div>
                                <div class="form-group">
                                    <label for="shadowSize">Taille de l'Ombre [largeur, hauteur]:</label>
                                    <input type="text" class="form-control" id="shadowSize" placeholder="Ex: [41, 41]">
                                </div>
                                <input type="hidden" id="iconAction" value="create">
                                <input type="hidden" id="originalIconName" value="">
                                <button type="submit" class="btn btn-primary">Enregistrer</button>
                                <button type="button" id="cancelIconBtn" class="btn btn-secondary">Annuler</button>
                                <button type="button" id="deleteIconBtn" class="btn btn-danger" style="display: none;">Supprimer</button>
                            </form>
                        </div>
                    </div>
                </div>

                <!-- Onglet Marqueurs -->
                <div class="tab-pane fade" id="markers" role="tabpanel" aria-labelledby="markers-tab">
                    <div class="row">
                        <div class="col-md-6">
                            <div class="d-flex justify-content-between mb-3">
                                <h4>Liste des Marqueurs</h4>
                                <button class="btn btn-sm btn-success" id="newMarkerBtn">Nouveau Marqueur</button>
                            </div>

                            <div class="list-group mb-3" id="markersList">
                                <!-- Les marqueurs seront ajoutés ici dynamiquement -->
                            </div>
                        </div>

                        <div class="col-md-6">
                            <form id="markerForm" style="display: none;">
                                <h5 id="markerFormTitle">Ajouter un Marqueur</h5>
                                <div class="form-group">
                                    <label for="markerId">ID du Marqueur:</label>
                                    <input type="text" class="form-control" id="markerId" required>
                                    <small class="form-text text-muted" id="markerIdFeedback"></small>
                                </div>
                                <div class="form-group">
                                    <label for="markerType">Type:</label>
                                    <select class="form-control" id="markerType" required>
                                        <option value="marker">Marqueur</option>
                                        <option value="polygon">Polygone</option>
                                    </select>
                                </div>
                                <div class="form-group">
                                    <label for="markerBound">Plan Associé:</label>
                                    <select class="form-control" id="markerBound" required>
                                        <option value="">Sélectionnez un plan...</option>
                                        <!-- Les plans seront ajoutés ici dynamiquement -->
                                    </select>
                                </div>
                                <div class="form-group marker-field">
                                    <label for="markerCoords">Coordonnées [x, y]:</label>
                                    <input type="text" class="form-control" id="markerCoords" placeholder="Ex: [800, 400]" required>
                                </div>
                                <div class="form-group polygon-field" style="display: none;">
                                    <label for="polygonCoords">Coordonnées du Polygone [[x1, y1], [x2, y2], ...]:</label>
                                    <textarea class="form-control" id="polygonCoords" rows="4" placeholder="Ex: [[800, 400], [900, 500], [700, 600]]"></textarea>
                                </div>
                                <div class="form-group marker-field">
                                    <label for="markerIcon">Icône:</label>
                                    <select class="form-control" id="markerIcon">
                                        <option value="">Marqueur par défaut</option>
                                        <!-- Les icônes seront ajoutées ici dynamiquement -->
                                    </select>
                                </div>
                                <div class="form-group">
                                    <label for="markerPopup">Texte du Popup:</label>
                                    <textarea class="form-control" id="markerPopup" rows="2"></textarea>
                                </div>
                                <input type="hidden" id="markerAction" value="create">
                                <input type="hidden" id="originalMarkerId" value="">
                                <button type="submit" class="btn btn-primary">Enregistrer</button>
                                <button type="button" id="cancelMarkerBtn" class="btn btn-secondary">Annuler</button>
                                <button type="button" id="deleteMarkerBtn" class="btn btn-danger" style="display: none;">Supprimer</button>
                            </form>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
{% endblock %}

{% block script %}
<script src="{% static 'js/Sortable.min.js' %}"></script>
<script>
    // Stocker les données JSON chargées depuis le serveur
    const mapData = {{ map_data|safe }};

    // Définir les chemins statiques
    const STATIC_URL_IMG = "{% static 'img/' %}";
    const STATIC_URL_MARKERS = "{% static 'markers/' %}";
    const STATIC_URL_PLANS = "{% static 'plans/' %}";
    const STATIC_URL_JSON = "{% static 'json/' %}";

    // Variables globales
    let map;
    let currentLayers = {};
    let currentMarkers = {};
    let currentPolygons = {};
    let iconsList = {};
    let drawingPolygon = false;
    let polygonPoints = [];
    let tempPolygon = null;
    let planOrder = [];

    // Initialiser la carte
    function initMap() {
        // Créer la carte avec les paramètres spécifiés
        map = L.map('map', {
            crs: L.CRS.Simple,
            minZoom: mapData.map.minZoom || -5,
            zoomDelta: mapData.map.zoomDelta || 0.25,
            zoomSnap: mapData.map.zoomSnap || 0
        });

        // Configurer les limites
        const bounds = mapData.bounds;
        map.fitBounds(bounds);

        // Créer les couches pour les différents plans
        currentLayers = {};
        if (mapData.plans) {
            // Récupérer l'ordre actuel des plans
            planOrder = Object.keys(mapData.plans);

            for (const [planId, plan] of Object.entries(mapData.plans)) {
                currentLayers[planId] = L.layerGroup();
                L.imageOverlay(STATIC_URL_PLANS + plan.image, bounds).addTo(currentLayers[planId]);

                // Ajouter les marqueurs associés à ce plan
                if (mapData.markers) {
                    for (const markerGroup of mapData.markers) {
                        for (const [markerId, marker] of Object.entries(markerGroup)) {
                            if (marker.bound === planId) {
                                addMarkerToMap(markerId, marker, planId);
                            }
                        }
                    }
                }
            }

            // Ajouter la couche par défaut à la carte
            if (mapData.map.layers && currentLayers[mapData.map.layers]) {
                currentLayers[mapData.map.layers].addTo(map);
            } else if (planOrder.length > 0) {
                currentLayers[planOrder[0]].addTo(map);
            }

            // Ajouter le contrôle de couches
            const baseMaps = {};
            for (const planId of planOrder) {
                if (mapData.plans[planId]) {
                    baseMaps[mapData.plans[planId].name] = currentLayers[planId];
                }
            }
            L.control.layers(baseMaps).addTo(map);
        }

        // Initialiser les icônes personnalisées
        if (mapData.icons) {
            iconsList = mapData.icons;
        }

        // Configurer la vue
        if (mapData.map.xy && mapData.map.z !== undefined) {
            map.setView([mapData.map.xy[0], mapData.map.xy[1]], mapData.map.z);
        }

        // Événement de clic pour obtenir les coordonnées
        map.on('click', function(e) {
            const x = Math.round(e.latlng.lat);
            const y = Math.round(e.latlng.lng);
            console.log(`[${x}, ${y}]`);

            // Si on est en train de dessiner un polygone, ajouter le point
            if (drawingPolygon) {
                polygonPoints.push([x, y]);

                // Mettre à jour le polygone temporaire
                if (tempPolygon) {
                    map.removeLayer(tempPolygon);
                }

                if (polygonPoints.length > 2) {
                    tempPolygon = L.polygon(polygonPoints, { color: '#ff7800' }).addTo(map);
                } else if (polygonPoints.length === 2) {
                    tempPolygon = L.polyline(polygonPoints, { color: '#ff7800' }).addTo(map);
                }

                // Mettre à jour le champ de texte des coordonnées
                document.getElementById('polygonCoords').value = JSON.stringify(polygonPoints);
            }
        });
    }

    // Ajouter un marqueur ou polygone à la carte
    function addMarkerToMap(markerId, markerData, planId) {
        if (!currentLayers[planId]) return;

        if (markerData.type === "marker") {
            const markerOptions = {};

            // Si une icône est spécifiée et existe dans notre liste d'icônes
            if (markerData.icon && iconsList[markerData.icon]) {
                const iconConfig = iconsList[markerData.icon];
                const iconUrl = iconConfig.iconUrl.startsWith('marker-') ?
                    STATIC_URL_MARKERS + iconConfig.iconUrl :
                    STATIC_URL_IMG + iconConfig.iconUrl;
                const shadowUrl = iconConfig.shadowUrl ?
                    (iconConfig.shadowUrl.startsWith('marker-') ?
                        STATIC_URL_MARKERS + iconConfig.shadowUrl :
                        STATIC_URL_IMG + iconConfig.shadowUrl) :
                '';

                markerOptions.icon = L.icon({
                    iconUrl: iconUrl,
                    shadowUrl: shadowUrl,
                    iconSize: iconConfig.iconSize || [25, 41],
                    iconAnchor: iconConfig.iconAnchor || [12, 41],
                    popupAnchor: iconConfig.popupAnchor || [1, -34],
                    shadowSize: iconConfig.shadowSize || [41, 41]
                });
            }

            // Créer et ajouter le marqueur à la couche correspondante
            const marker = L.marker(markerData.xy, markerOptions)
                .bindPopup(markerData.popup || '')
                .addTo(currentLayers[planId]);

            // Stocker le marqueur pour pouvoir le supprimer plus tard
            if (!currentMarkers[planId]) currentMarkers[planId] = {};
            currentMarkers[planId][markerId] = marker;

        } else if (markerData.type === "polygon") {
            // Créer et ajouter le polygone à la couche correspondante
            const polygon = L.polygon(markerData.xy, {
                color: markerData.color || '#3388ff'
            })
                .bindPopup(markerData.popup || '')
                .addTo(currentLayers[planId]);

            // Stocker le polygone pour pouvoir le supprimer plus tard
            if (!currentPolygons[planId]) currentPolygons[planId] = {};
            currentPolygons[planId][markerId] = polygon;
        }
    }

    // Mettre à jour les listes déroulantes des plans
    function updatePlansDropdowns() {
        const defaultLayer = document.getElementById('defaultLayer');
        const markerBound = document.getElementById('markerBound');

        // Vider les listes
        defaultLayer.innerHTML = '<option value="">Sélectionnez un plan...</option>';
        markerBound.innerHTML = '<option value="">Sélectionnez un plan...</option>';

        // Ajouter les plans dans l'ordre actuel
        if (mapData.plans) {
            for (const planId of planOrder) {
                if (mapData.plans[planId]) {
                    const plan = mapData.plans[planId];

                    // Ajouter l'option au dropdown defaultLayer
                    const optionDefault = document.createElement('option');
                    optionDefault.value = planId;
                    optionDefault.textContent = plan.name;
                    defaultLayer.appendChild(optionDefault);

                    // Ajouter l'option au dropdown markerBound
                    const optionBound = document.createElement('option');
                    optionBound.value = planId;
                    optionBound.textContent = plan.name;
                    markerBound.appendChild(optionBound);
                }
            }
        }

        // Sélectionner la couche par défaut actuelle
        if (mapData.map && mapData.map.layers) {
            defaultLayer.value = mapData.map.layers;
        }
    }

    // Mettre à jour la liste des plans dans l'interface
    function updatePlansList() {
        const plansList = document.getElementById('plansList');
        plansList.innerHTML = '';

        const plansOrderList = document.getElementById('plansOrderList');
        plansOrderList.innerHTML = '';

        if (mapData.plans) {
            for (const planId of planOrder) {
                if (mapData.plans[planId]) {
                    const plan = mapData.plans[planId];

                    // Créer l'élément pour la liste des plans
                    const listItem = document.createElement('a');
                    listItem.className = 'list-group-item list-group-item-action d-flex align-items-center';
                    listItem.setAttribute('data-plan-id', planId);

                    // Créer une prévisualisation du plan
                    const planPreview = document.createElement('img');
                    planPreview.src = STATIC_URL_PLANS + plan.image;
                    planPreview.className = 'plan-preview me-3';
                    planPreview.alt = plan.name;

                    const textSpan = document.createElement('span');
                    textSpan.innerHTML = `<strong>${planId}</strong>: ${plan.name}`;

                    listItem.appendChild(planPreview);
                    listItem.appendChild(textSpan);

                    // Ajouter l'événement de clic pour éditer le plan
                    listItem.addEventListener('click', function() {
                        editPlan(planId);
                    });

                    plansList.appendChild(listItem);

                    // Créer l'élément pour la liste d'ordre des plans
                    const orderItem = document.createElement('div');
                    orderItem.className = 'list-group-item d-flex align-items-center';
                    orderItem.setAttribute('data-plan-id', planId);

                    const dragHandle = document.createElement('div');
                    dragHandle.className = 'drag-handle me-3';
                    dragHandle.innerHTML = '<i class="fas fa-grip-vertical"></i>';

                    const previewContainer = document.createElement('div');
                    previewContainer.className = 'plan-preview-container';

                    const orderPreview = document.createElement('img');
                    orderPreview.src = STATIC_URL_PLANS + plan.image;
                    orderPreview.className = 'plan-preview';
                    orderPreview.alt = plan.name;

                    previewContainer.appendChild(orderPreview);

                    const orderTextSpan = document.createElement('span');
                    orderTextSpan.textContent = plan.name;

                    orderItem.appendChild(dragHandle);
                    orderItem.appendChild(previewContainer);
                    orderItem.appendChild(orderTextSpan);

                    plansOrderList.appendChild(orderItem);
                }
            }
        }

        // Initialiser le tri par glisser-déposer pour l'ordre des plans
        initSortable();
    }

    // Initialiser le tri par glisser-déposer
    function initSortable() {
        const plansOrderList = document.getElementById('plansOrderList');
        new Sortable(plansOrderList, {
            handle: '.drag-handle',
            animation: 150,
            onEnd: function(evt) {
                // Mettre à jour l'ordre des plans
                const items = plansOrderList.querySelectorAll('.list-group-item');
                planOrder = [];
                for (const item of items) {
                    planOrder.push(item.getAttribute('data-plan-id'));
                }
            }
        });
    }

    // Mettre à jour la liste des icônes dans l'interface
    function updateIconsList() {
        const iconsList = document.getElementById('iconsList');
        iconsList.innerHTML = '';

        if (mapData.icons) {
            for (const [iconName, iconConfig] of Object.entries(mapData.icons)) {
                const listItem = document.createElement('a');
                listItem.className = 'list-group-item list-group-item-action d-flex justify-content-between align-items-center';
                listItem.setAttribute('data-icon-name', iconName);

                // Créer une prévisualisation de l'icône
                const iconPreview = document.createElement('img');
                iconPreview.src = STATIC_URL_MARKERS + iconConfig.iconUrl;
                iconPreview.className = 'icon-preview me-3';
                iconPreview.alt = iconName;

                const textSpan = document.createElement('span');
                textSpan.textContent = iconName;

                listItem.appendChild(iconPreview);
                listItem.appendChild(textSpan);

                // Ajouter l'événement de clic pour éditer l'icône
                listItem.addEventListener('click', function() {
                    editIcon(iconName);
                });

                iconsList.appendChild(listItem);
            }
        }
    }

    // Mettre à jour la liste déroulante des icônes pour les marqueurs
    function updateIconsDropdown() {
        const markerIcon = document.getElementById('markerIcon');

        // Conserver uniquement l'option par défaut
        while (markerIcon.options.length > 1) {
            markerIcon.remove(1);
        }

        // Ajouter les icônes disponibles
        if (mapData.icons) {
            for (const iconName of Object.keys(mapData.icons)) {
                const option = document.createElement('option');
                option.value = iconName;
                option.textContent = iconName;
                markerIcon.appendChild(option);
            }
        }
    }

    // Mettre à jour la liste des marqueurs dans l'interface
    function updateMarkersList() {
        const markersList = document.getElementById('markersList');
        markersList.innerHTML = '';

        if (mapData.markers) {
            for (const markerGroup of mapData.markers) {
                for (const [markerId, marker] of Object.entries(markerGroup)) {
                    const listItem = document.createElement('a');
                    listItem.className = 'list-group-item list-group-item-action d-flex justify-content-between align-items-center';
                    listItem.setAttribute('data-marker-id', markerId);

                    // Icône du type (marqueur ou polygone)
                    const typeIcon = document.createElement('i');
                    typeIcon.className = `fas fa-${marker.type === 'marker' ? 'map-marker-alt' : 'draw-polygon'} me-2`;

                    const textSpan = document.createElement('span');
                    textSpan.innerHTML = `<strong>${markerId}</strong>: ${marker.popup || 'Sans popup'}`;

                    const boundSpan = document.createElement('small');
                    boundSpan.className = 'badge bg-info text-white ms-2';
                    boundSpan.textContent = marker.bound || 'Sans plan';

                    listItem.appendChild(typeIcon);
                    listItem.appendChild(textSpan);
                    listItem.appendChild(boundSpan);

                    // Ajouter l'événement de clic pour éditer le marqueur
                    listItem.addEventListener('click', function() {
                        editMarker(markerId);
                    });

                    markersList.appendChild(listItem);
                }
            }
        }
    }

    // Éditer un plan existant
    function editPlan(planId) {
        const plan = mapData.plans[planId];

        // Mettre à jour le formulaire avec les valeurs actuelles
        document.getElementById('planId').value = planId;
        document.getElementById('planName').value = plan.name || '';
        document.getElementById('planImage').value = plan.image || '';

        // Changer l'action et afficher le formulaire
        document.getElementById('planAction').value = 'update';
        document.getElementById('originalPlanId').value = planId;
        document.getElementById('planFormTitle').textContent = 'Modifier un Plan';
        document.getElementById('deletePlanBtn').style.display = 'inline-block';
        document.getElementById('planForm').style.display = 'block';
    }

    // Éditer une icône existante
    function editIcon(iconName) {
        const iconConfig = mapData.icons[iconName];

        // Mettre à jour le formulaire avec les valeurs actuelles
        document.getElementById('iconName').value = iconName;
        document.getElementById('iconUrl').value = iconConfig.iconUrl || '';
        document.getElementById('shadowUrl').value = iconConfig.shadowUrl || '';
        document.getElementById('iconSize').value = iconConfig.iconSize ? JSON.stringify(iconConfig.iconSize) : '';
        document.getElementById('iconAnchor').value = iconConfig.iconAnchor ? JSON.stringify(iconConfig.iconAnchor) : '';
        document.getElementById('popupAnchor').value = iconConfig.popupAnchor ? JSON.stringify(iconConfig.popupAnchor) : '';
        document.getElementById('shadowSize').value = iconConfig.shadowSize ? JSON.stringify(iconConfig.shadowSize) : '';

        // Changer l'action et afficher le formulaire
        document.getElementById('iconAction').value = 'update';
        document.getElementById('originalIconName').value = iconName;
        document.getElementById('iconFormTitle').textContent = 'Modifier une Icône';
        document.getElementById('deleteIconBtn').style.display = 'inline-block';
        document.getElementById('iconForm').style.display = 'block';
    }

    // Trouver et éditer un marqueur existant
    function editMarker(markerId) {
        let markerData = null;
        let markerGroupIndex = -1;

        // Rechercher le marqueur dans les groupes
        for (let i = 0; i < mapData.markers.length; i++) {
            if (markerId in mapData.markers[i]) {
                markerData = mapData.markers[i][markerId];
                markerGroupIndex = i;
                break;
            }
        }

        if (!markerData) return;

        // Mettre à jour le formulaire avec les valeurs actuelles
        document.getElementById('markerId').value = markerId;
        document.getElementById('markerType').value = markerData.type;
        document.getElementById('markerBound').value = markerData.bound || '';

        // Afficher/masquer les champs appropriés selon le type
        toggleMarkerFields(markerData.type);

        if (markerData.type === 'marker') {
            document.getElementById('markerCoords').value = JSON.stringify(markerData.xy);
            document.getElementById('markerIcon').value = markerData.icon || '';
        } else if (markerData.type === 'polygon') {
            document.getElementById('polygonCoords').value = JSON.stringify(markerData.xy);
        }

        document.getElementById('markerPopup').value = markerData.popup || '';

        // Changer l'action et afficher le formulaire
        document.getElementById('markerAction').value = 'update';
        document.getElementById('originalMarkerId').value = markerId;
        document.getElementById('markerFormTitle').textContent = 'Modifier un Marqueur';
        document.getElementById('deleteMarkerBtn').style.display = 'inline-block';
        document.getElementById('markerForm').style.display = 'block';
    }

    // Basculer l'affichage des champs selon le type de marqueur
    function toggleMarkerFields(type) {
        const markerFields = document.querySelectorAll('.marker-field');
        const polygonFields = document.querySelectorAll('.polygon-field');

        if (type === 'marker') {
            markerFields.forEach(field => field.style.display = 'block');
            polygonFields.forEach(field => field.style.display = 'none');
        } else if (type === 'polygon') {
            markerFields.forEach(field => field.style.display = 'none');
            polygonFields.forEach(field => field.style.display = 'block');
        }
    }

    // Sauvegarder les modifications sur le serveur
    async function saveToServer(data) {
        try {
            const response = await fetch(window.location.href, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'X-Requested-With': 'XMLHttpRequest',
                    'X-CSRFToken': getCookie('csrftoken')
                },
                body: JSON.stringify(data)
            });

            const result = await response.json();

            if (result.status === 'success') {
                return true;
            } else {
                alert('Erreur lors de la sauvegarde: ' + (result.message || 'Erreur inconnue'));
                return false;
            }
        } catch (error) {
            alert('Erreur lors de la sauvegarde: ' + error.message);
            return false;
        }
    }

    // Obtenir la valeur d'un cookie (pour CSRF)
    function getCookie(name) {
        let cookieValue = null;
        if (document.cookie && document.cookie !== '') {
            const cookies = document.cookie.split(';');
            for (let i = 0; i < cookies.length; i++) {
                const cookie = cookies[i].trim();
                if (cookie.substring(0, name.length + 1) === (name + '=')) {
                    cookieValue = decodeURIComponent(cookie.substring(name.length + 1));
                    break;
                }
            }
        }
        return cookieValue;
    }

    // Vérifie si le nom d'icône est unique
    function isIconNameUnique(name, originalName) {
        // Si c'est une mise à jour et que le nom n'a pas changé, c'est valide
        if (name === originalName) return true;

        // Vérifier si le nom existe déjà dans les icônes
        return !(mapData.icons && mapData.icons.hasOwnProperty(name));
    }

    // Vérifie si l'ID du plan est unique
    function isPlanIdUnique(id, originalId) {
        // Si c'est une mise à jour et que l'ID n'a pas changé, c'est valide
        if (id === originalId) return true;

        // Vérifier si l'ID existe déjà dans les plans
        return !(mapData.plans && mapData.plans.hasOwnProperty(id));
    }

    // Vérifie si l'ID du marqueur est unique
    function isMarkerIdUnique(id, originalId) {
        // Si c'est une mise à jour et que l'ID n'a pas changé, c'est valide
        if (id === originalId) return true;

        // Vérifier si l'ID existe déjà dans les marqueurs
        for (const markerGroup of mapData.markers) {
            if (id in markerGroup && id !== originalId) {
                return false;
            }
        }
        return true;
    }

    // Initialiser l'application quand le DOM est chargé
    document.addEventListener('DOMContentLoaded', function() {
        // Initialiser la carte
        initMap();

        // Mettre à jour les listes
        updatePlansList();
        updateIconsList();
        updateIconsDropdown();
        updatePlansDropdowns();
        updateMarkersList();

        // Remplir le formulaire de paramètres avec les valeurs actuelles
        document.getElementById('minX').value = mapData.bounds[0][0];
        document.getElementById('minY').value = mapData.bounds[0][1];
        document.getElementById('maxX').value = mapData.bounds[1][0];
        document.getElementById('maxY').value = mapData.bounds[1][1];

        document.getElementById('minZoom').value = mapData.map.minZoom || -5;
        document.getElementById('zoomDelta').value = mapData.map.zoomDelta || 0.25;
        document.getElementById('zoomSnap').value = mapData.map.zoomSnap || 0;
        document.getElementById('defaultLayer').value = mapData.map.layers || '';
        document.getElementById('centerX').value = mapData.map.xy ? mapData.map.xy[0] : 0;
        document.getElementById('centerY').value = mapData.map.xy ? mapData.map.xy[1] : 0;
        document.getElementById('defaultZoom').value = mapData.map.z || 0;

        // Événement pour utiliser les limites actuelles de la carte
        document.getElementById('useCurrentBounds').addEventListener('click', function() {
            const bounds = map.getBounds();
            const sw = bounds.getSouthWest();
            const ne = bounds.getNorthEast();

            document.getElementById('minX').value = Math.round(sw.lat);
            document.getElementById('minY').value = Math.round(sw.lng);
            document.getElementById('maxX').value = Math.round(ne.lat);
            document.getElementById('maxY').value = Math.round(ne.lng);

            const center = map.getCenter();
            document.getElementById('centerX').value = Math.round(center.lat);
            document.getElementById('centerY').value = Math.round(center.lng);
            document.getElementById('defaultZoom').value = map.getZoom();
        });

        // Événement de soumission du formulaire de paramètres
        document.getElementById('settingsForm').addEventListener('submit', async function(e) {
            e.preventDefault();

            const minX = parseInt(document.getElementById('minX').value);
            const minY = parseInt(document.getElementById('minY').value);
            const maxX = parseInt(document.getElementById('maxX').value);
            const maxY = parseInt(document.getElementById('maxY').value);

            const minZoom = parseFloat(document.getElementById('minZoom').value);
            const zoomDelta = parseFloat(document.getElementById('zoomDelta').value);
            const zoomSnap = parseFloat(document.getElementById('zoomSnap').value);
            const defaultLayer = document.getElementById('defaultLayer').value;
            const centerX = parseInt(document.getElementById('centerX').value);
            const centerY = parseInt(document.getElementById('centerY').value);
            const defaultZoom = parseFloat(document.getElementById('defaultZoom').value);

            // Mettre à jour les données locales
            mapData.bounds = [[minX, minY], [maxX, maxY]];
            mapData.map = {
                minZoom: minZoom,
                zoomDelta: zoomDelta,
                zoomSnap: zoomSnap,
                layers: defaultLayer,
                xy: [centerX, centerY],
                z: defaultZoom
            };

            // Envoyer les données au serveur
            const success = await saveToServer({
                action: 'update_bounds_map',
                bounds: mapData.bounds,
                map: mapData.map
            });

            if (success) {
                // Recharger la page pour appliquer les changements
                alert('Paramètres mis à jour avec succès! La page va être rechargée.');
                window.location.reload();
            }
        });

        // Événements pour le formulaire de plans
        document.getElementById('newPlanBtn').addEventListener('click', function() {
            // Réinitialiser le formulaire
            document.getElementById('planForm').reset();
            document.getElementById('planAction').value = 'create';
            document.getElementById('originalPlanId').value = '';
            document.getElementById('planFormTitle').textContent = 'Ajouter un Plan';
            document.getElementById('deletePlanBtn').style.display = 'none';
            document.getElementById('planForm').style.display = 'block';
        });

        document.getElementById('cancelPlanBtn').addEventListener('click', function() {
            document.getElementById('planForm').style.display = 'none';
        });

        document.getElementById('planForm').addEventListener('submit', async function(e) {
            e.preventDefault();

            // Récupérer les valeurs du formulaire
            const planId = document.getElementById('planId').value;
            const planName = document.getElementById('planName').value;
            const planImage = document.getElementById('planImage').value;
            const originalPlanId = document.getElementById('originalPlanId').value;

            // Vérifier que l'ID est unique
            if (!isPlanIdUnique(planId, originalPlanId)) {
                alert('Cet ID de plan existe déjà. Veuillez en choisir un autre.');
                return;
            }

            // Préparer les données du plan
            const planData = {
                name: planName,
                image: planImage
            };

            // Déterminer l'action (création ou mise à jour)
            const planAction = document.getElementById('planAction').value;

            // Mettre à jour les données locales
            if (!mapData.plans) mapData.plans = {};

            // Si c'est une mise à jour et que l'ID a changé, supprimer l'ancienne entrée
            if (planAction === 'update' && originalPlanId !== planId) {
                delete mapData.plans[originalPlanId];

                // Mettre à jour l'ordre des plans
                const index = planOrder.indexOf(originalPlanId);
                if (index !== -1) {
                    planOrder.splice(index, 1, planId);
                }
            } else if (planAction === 'create') {
                // Ajouter le nouveau plan à la fin de l'ordre
                planOrder.push(planId);
            }

            mapData.plans[planId] = planData;

            // Envoyer les données au serveur
            const success = await saveToServer({
                action: 'crud_plan',
                plan_action: planAction,
                plan_id: planId,
                plan_data: planData,
                original_plan_id: originalPlanId
            });

            if (success) {
                // Mettre à jour l'interface
                updatePlansList();
                updatePlansDropdowns();
                document.getElementById('planForm').style.display = 'none';
                alert(`Plan ${planAction === 'create' ? 'ajouté' : 'mis à jour'} avec succès!`);
            }
        });

        document.getElementById('deletePlanBtn').addEventListener('click', async function() {
            const planId = document.getElementById('originalPlanId').value;

            if (confirm(`Êtes-vous sûr de vouloir supprimer le plan "${planId}" ?`)) {
                // Supprimer le plan des données locales
                if (mapData.plans && mapData.plans[planId]) {
                    delete mapData.plans[planId];

                    // Mettre à jour l'ordre des plans
                    const index = planOrder.indexOf(planId);
                    if (index !== -1) {
                        planOrder.splice(index, 1);
                    }
                }

                // Envoyer la demande de suppression au serveur
                const success = await saveToServer({
                    action: 'crud_plan',
                    plan_action: 'delete',
                    plan_id: planId
                });

                if (success) {
                    // Mettre à jour l'interface
                    updatePlansList();
                    updatePlansDropdowns();
                    document.getElementById('planForm').style.display = 'none';
                    alert('Plan supprimé avec succès!');
                }
            }
        });

        // Enregistrer l'ordre des plans
        document.getElementById('saveOrderBtn').addEventListener('click', async function() {
            // Envoyer la demande de réordonnancement au serveur
            const success = await saveToServer({
                action: 'crud_plan',
                plan_action: 'reorder',
                new_order: planOrder
            });

            if (success) {
                alert('Ordre des plans mis à jour avec succès!');
            }
        });

        // Événements pour le formulaire d'icônes
        document.getElementById('newIconBtn').addEventListener('click', function() {
            // Réinitialiser le formulaire
            document.getElementById('iconForm').reset();
            document.getElementById('iconAction').value = 'create';
            document.getElementById('originalIconName').value = '';
            document.getElementById('iconFormTitle').textContent = 'Ajouter une Icône';
            document.getElementById('deleteIconBtn').style.display = 'none';
            document.getElementById('iconForm').style.display = 'block';
        });

        document.getElementById('cancelIconBtn').addEventListener('click', function() {
            document.getElementById('iconForm').style.display = 'none';
        });

        document.getElementById('iconForm').addEventListener('submit', async function(e) {
            e.preventDefault();

            // Récupérer les valeurs du formulaire
            const iconName = document.getElementById('iconName').value;
            const iconUrl = document.getElementById('iconUrl').value;
            const shadowUrl = document.getElementById('shadowUrl').value;
            const iconSize = document.getElementById('iconSize').value;
            const iconAnchor = document.getElementById('iconAnchor').value;
            const popupAnchor = document.getElementById('popupAnchor').value;
            const shadowSize = document.getElementById('shadowSize').value;

            // Vérifier que le nom est unique
            const originalIconName = document.getElementById('originalIconName').value;
            const isUnique = isIconNameUnique(iconName, originalIconName);

            if (!isUnique) {
                document.getElementById('iconNameFeedback').textContent = 'Ce nom d\'icône existe déjà. Veuillez en choisir un autre.';
                document.getElementById('iconNameFeedback').style.color = 'red';
                return;
            } else {
                document.getElementById('iconNameFeedback').textContent = '';
            }

            // Préparer les données de l'icône
            const iconData = {
                iconUrl: iconUrl
            };

            if (shadowUrl) iconData.shadowUrl = shadowUrl;
            if (iconSize) {
                try {
                    iconData.iconSize = JSON.parse(iconSize);
                } catch (error) {
                    alert('Format invalide pour la taille de l\'icône. Utilisez le format [largeur, hauteur]');
                    return;
                }
            }
            if (iconAnchor) {
                try {
                    iconData.iconAnchor = JSON.parse(iconAnchor);
                } catch (error) {
                    alert('Format invalide pour l\'ancre de l\'icône. Utilisez le format [x, y]');
                    return;
                }
            }
            if (popupAnchor) {
                try {
                    iconData.popupAnchor = JSON.parse(popupAnchor);
                } catch (error) {
                    alert('Format invalide pour l\'ancre du popup. Utilisez le format [x, y]');
                    return;
                }
            }
            if (shadowSize) {
                try {
                    iconData.shadowSize = JSON.parse(shadowSize);
                } catch (error) {
                    alert('Format invalide pour la taille de l\'ombre. Utilisez le format [largeur, hauteur]');
                    return;
                }
            }

            // Déterminer l'action (création ou mise à jour)
            const iconAction = document.getElementById('iconAction').value;

            // Mettre à jour les données locales
            if (!mapData.icons) mapData.icons = {};

            // Si c'est une mise à jour et que le nom a changé, supprimer l'ancienne entrée
            if (iconAction === 'update' && originalIconName !== iconName) {
                delete mapData.icons[originalIconName];
            }

            mapData.icons[iconName] = iconData;

            // Envoyer les données au serveur
            const success = await saveToServer({
                action: 'crud_icon',
                icon_action: iconAction,
                icon_name: iconName,
                icon_data: iconData,
                original_icon_name: originalIconName
            });

            if (success) {
                // Mettre à jour l'interface
                updateIconsList();
                updateIconsDropdown();
                document.getElementById('iconForm').style.display = 'none';
                alert(`Icône ${iconAction === 'create' ? 'ajoutée' : 'mise à jour'} avec succès!`);
            }
        });

        // Ajouter une validation en temps réel pour le nom d'icône
        document.getElementById('iconName').addEventListener('input', function() {
            const iconName = this.value;
            const originalIconName = document.getElementById('originalIconName').value;
            const isUnique = isIconNameUnique(iconName, originalIconName);

            if (!isUnique) {
                document.getElementById('iconNameFeedback').textContent = 'Ce nom d\'icône existe déjà. Veuillez en choisir un autre.';
                document.getElementById('iconNameFeedback').style.color = 'red';
            } else {
                document.getElementById('iconNameFeedback').textContent = 'Nom d\'icône valide.';
                document.getElementById('iconNameFeedback').style.color = 'green';
            }
        });

        // Ajouter une validation en temps réel pour l'ID du plan
        document.getElementById('planId').addEventListener('input', function() {
            const planId = this.value;
            const originalPlanId = document.getElementById('originalPlanId').value;
            const isUnique = isPlanIdUnique(planId, originalPlanId);
            const feedbackElement = document.getElementById('planIdFeedback');

            if (!isUnique) {
                feedbackElement.textContent = 'Cet ID de plan existe déjà. Veuillez en choisir un autre.';
                feedbackElement.style.color = 'red';
            } else {
                feedbackElement.textContent = 'ID de plan valide.';
                feedbackElement.style.color = 'green';
            }
        });

        // Ajouter une validation en temps réel pour l'ID du marqueur
        document.getElementById('markerId').addEventListener('input', function() {
            const markerId = this.value;
            const originalMarkerId = document.getElementById('originalMarkerId').value;
            const isUnique = isMarkerIdUnique(markerId, originalMarkerId);
            const feedbackElement = document.getElementById('markerIdFeedback');

            if (!isUnique) {
                feedbackElement.textContent = 'Cet ID de marqueur existe déjà. Veuillez en choisir un autre.';
                feedbackElement.style.color = 'red';
            } else {
                feedbackElement.textContent = 'ID de marqueur valide.';
                feedbackElement.style.color = 'green';
            }
        });

        document.getElementById('deleteIconBtn').addEventListener('click', async function() {
            const iconName = document.getElementById('originalIconName').value;

            if (confirm(`Êtes-vous sûr de vouloir supprimer l'icône "${iconName}" ?`)) {
                // Supprimer l'icône des données locales
                if (mapData.icons && mapData.icons[iconName]) {
                    delete mapData.icons[iconName];
                }

                // Envoyer la demande de suppression au serveur
                const success = await saveToServer({
                    action: 'crud_icon',
                    icon_action: 'delete',
                    icon_name: iconName
                });

                if (success) {
                    // Mettre à jour l'interface
                    updateIconsList();
                    updateIconsDropdown();
                    document.getElementById('iconForm').style.display = 'none';
                    alert('Icône supprimée avec succès!');
                }
            }
        });

        // Événements pour le formulaire de marqueurs
        document.getElementById('newMarkerBtn').addEventListener('click', function() {
            // Réinitialiser le formulaire
            document.getElementById('markerForm').reset();
            document.getElementById('markerAction').value = 'create';
            document.getElementById('originalMarkerId').value = '';
            document.getElementById('markerFormTitle').textContent = 'Ajouter un Marqueur';
            document.getElementById('deleteMarkerBtn').style.display = 'none';
            toggleMarkerFields('marker'); // Par défaut, afficher les champs pour un marqueur
            document.getElementById('markerForm').style.display = 'block';
        });

        document.getElementById('cancelMarkerBtn').addEventListener('click', function() {
            document.getElementById('markerForm').style.display = 'none';
            drawingPolygon = false;
            polygonPoints = [];
            if (tempPolygon) {
                map.removeLayer(tempPolygon);
                tempPolygon = null;
            }
        });

        document.getElementById('markerType').addEventListener('change', function() {
            toggleMarkerFields(this.value);
        });

        // Bouton pour activer/désactiver le mode de dessin de polygone
        document.getElementById('polygonCoords').addEventListener('focus', function() {
            if (!drawingPolygon) {
                drawingPolygon = true;
                polygonPoints = [];
                alert('Mode dessin de polygone activé. Cliquez sur la carte pour ajouter des points. Cliquez sur Enregistrer quand vous avez terminé.');
            }
        });

        document.getElementById('markerForm').addEventListener('submit', async function(e) {
            e.preventDefault();

            // Récupérer les valeurs du formulaire
            const markerId = document.getElementById('markerId').value;
            const markerType = document.getElementById('markerType').value;
            const markerBound = document.getElementById('markerBound').value;
            const originalMarkerId = document.getElementById('originalMarkerId').value;

            // Vérifier que l'ID est unique
            if (!isMarkerIdUnique(markerId, originalMarkerId)) {
                alert('Cet ID de marqueur existe déjà. Veuillez en choisir un autre.');
                return;
            }

            if (!markerBound) {
                alert('Vous devez sélectionner un plan associé pour ce marqueur.');
                return;
            }

            if (!markerBound) {
                alert('Vous devez sélectionner un plan associé pour ce marqueur.');
                return;
            }

            // Préparer les données du marqueur
            const markerData = {
                type: markerType,
                bound: markerBound
            };

            if (markerType === 'marker') {
                try {
                    markerData.xy = JSON.parse(document.getElementById('markerCoords').value);
                } catch (error) {
                    alert('Format invalide pour les coordonnées. Utilisez le format [x, y]');
                    return;
                }

                const iconValue = document.getElementById('markerIcon').value;
                if (iconValue) markerData.icon = iconValue;

            } else if (markerType === 'polygon') {
                try {
                    markerData.xy = JSON.parse(document.getElementById('polygonCoords').value);
                } catch (error) {
                    alert('Format invalide pour les coordonnées du polygone. Utilisez le format [[x1, y1], [x2, y2], ...]');
                    return;
                }
            }

            const popupValue = document.getElementById('markerPopup').value;
            if (popupValue) markerData.popup = popupValue;

            // Déterminer l'action (création ou mise à jour)
            const markerAction = document.getElementById('markerAction').value;

            // Trouver l'index du marqueur si c'est une mise à jour
            let markerGroupIndex = -1;
            if (markerAction === 'update') {
                for (let i = 0; i < mapData.markers.length; i++) {
                    if (originalMarkerId in mapData.markers[i]) {
                        markerGroupIndex = i;
                        break;
                    }
                }
            }

            // Si c'est une mise à jour, supprimer le marqueur existant de la carte
            if (markerAction === 'update') {
                // Supprimer de la couche
                const oldBound = markerGroupIndex !== -1 ? mapData.markers[markerGroupIndex][originalMarkerId].bound : null;

                if (oldBound && currentMarkers[oldBound] && currentMarkers[oldBound][originalMarkerId]) {
                    map.removeLayer(currentMarkers[oldBound][originalMarkerId]);
                    delete currentMarkers[oldBound][originalMarkerId];
                }

                if (oldBound && currentPolygons[oldBound] && currentPolygons[oldBound][originalMarkerId]) {
                    map.removeLayer(currentPolygons[oldBound][originalMarkerId]);
                    delete currentPolygons[oldBound][originalMarkerId];
                }
            }

            // Mettre à jour les données locales
            if (!mapData.markers) mapData.markers = [];

            // Si c'est une mise à jour, mettre à jour le marqueur existant
            if (markerAction === 'update' && markerGroupIndex !== -1) {
                // Si l'ID a changé, supprimer l'ancienne entrée
                if (originalMarkerId !== markerId) {
                    delete mapData.markers[markerGroupIndex][originalMarkerId];
                }
                mapData.markers[markerGroupIndex][markerId] = markerData;
            } else {
                // Créer un nouveau groupe pour ce marqueur
                const newMarker = {};
                newMarker[markerId] = markerData;
                mapData.markers.push(newMarker);
            }

            // Ajouter le nouveau marqueur à la carte
            if (currentLayers[markerBound]) {
                addMarkerToMap(markerId, markerData, markerBound);
            }

            // Envoyer les données au serveur
            const success = await saveToServer({
                action: 'crud_marker',
                marker_action: markerAction,
                marker_id: markerId,
                marker_data: markerData,
                original_marker_id: originalMarkerId
            });

            if (success) {
                // Mettre à jour l'interface
                updateMarkersList();
                document.getElementById('markerForm').style.display = 'none';
                alert(`Marqueur ${markerAction === 'create' ? 'ajouté' : 'mis à jour'} avec succès!`);

                // Réinitialiser le mode dessin de polygone
                drawingPolygon = false;
                polygonPoints = [];
                if (tempPolygon) {
                    map.removeLayer(tempPolygon);
                    tempPolygon = null;
                }
            }
        });

        document.getElementById('deleteMarkerBtn').addEventListener('click', async function() {
            const markerId = document.getElementById('originalMarkerId').value;

            if (confirm(`Êtes-vous sûr de vouloir supprimer le marqueur "${markerId}" ?`)) {
                // Trouver le marqueur
                let markerData = null;
                let markerGroupIndex = -1;

                for (let i = 0; i < mapData.markers.length; i++) {
                    if (markerId in mapData.markers[i]) {
                        markerData = mapData.markers[i][markerId];
                        markerGroupIndex = i;
                        break;
                    }
                }

                if (markerData && markerData.bound) {
                    // Supprimer le marqueur de la carte
                    if (currentMarkers[markerData.bound] && currentMarkers[markerData.bound][markerId]) {
                        map.removeLayer(currentMarkers[markerData.bound][markerId]);
                        delete currentMarkers[markerData.bound][markerId];
                    }

                    if (currentPolygons[markerData.bound] && currentPolygons[markerData.bound][markerId]) {
                        map.removeLayer(currentPolygons[markerData.bound][markerId]);
                        delete currentPolygons[markerData.bound][markerId];
                    }
                }

                // Supprimer le marqueur des données locales
                if (markerGroupIndex !== -1) {
                    delete mapData.markers[markerGroupIndex][markerId];

                    // Si le groupe est vide, le supprimer complètement
                    if (Object.keys(mapData.markers[markerGroupIndex]).length === 0) {
                        mapData.markers.splice(markerGroupIndex, 1);
                    }
                }

                // Envoyer la demande de suppression au serveur
                const success = await saveToServer({
                    action: 'crud_marker',
                    marker_action: 'delete',
                    marker_id: markerId
                });

                if (success) {
                    // Mettre à jour l'interface
                    updateMarkersList();
                    document.getElementById('markerForm').style.display = 'none';
                    alert('Marqueur supprimé avec succès!');
                }
            }
        });
    });
</script>
{% endblock %}