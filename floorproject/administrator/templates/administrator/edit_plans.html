<!-- floorproject/administrator/templates/administrator/edit_plans.html -->
{% extends 'administrator/base.html' %}
{% load static %}

{% block title %}Edition of Plans{% endblock %}

{% block css %}
<style>
    html, body {
        height: 100%;
        margin: 0;
    }
    .leaflet-container {
        height: 400px;
        width: 100%;
        max-width: 100%;
        max-height: 100%;
    }
    .edit-panel {
        background-color: #f8f9fa;
        padding: 15px;
        border-radius: 5px;
        margin-bottom: 20px;
    }
    .tab-pane {
        padding: 15px;
    }
    .form-group {
        margin-bottom: 15px;
    }
    .icon-preview {
        width: 40px;
        height: 40px;
    }
    .plan-preview {
        max-width: 100px;
        max-height: 100px;
        object-fit: contain;
    }
    .list-group-item {
        cursor: pointer;
    }
    .list-group-item:hover {
        background-color: #f5f5f5;
    }
    .active-item {
        background-color: #e9ecef;
    }
    .drag-handle {
        cursor: move;
        padding: 5px;
    }
    #plansOrderList .list-group-item {
        display: flex;
        align-items: center;
    }
    .plan-preview-container {
        width: 100px;
        margin-right: 10px;
    }
</style>
{% endblock %}

{% block content %}
<div class="container-fluid">
    <h2 class="mb-4">Edition of Plans</h2>

    <!-- Map to visualize and interact -->
    <div class="row mb-4">
        <div class="col-md-12">
            <div id="map" style="width: 50%; height: 500px;" class="leaflet-container"></div>
        </div>
    </div>

    <!-- Editing Panel -->
    <div class="row" style="width: 50%; height: 500px;">
        <div class="col-md-12">
            <ul class="nav nav-tabs" id="editionTabs" role="tablist">
                <li class="nav-item" role="presentation">
                    <button class="nav-link active" id="settings-tab" data-bs-toggle="tab" data-bs-target="#settings" type="button" role="tab" aria-controls="settings" aria-selected="true">Settings</button>
                </li>
                <li class="nav-item" role="presentation">
                    <button class="nav-link" id="plans-tab" data-bs-toggle="tab" data-bs-target="#plans" type="button" role="tab" aria-controls="plans" aria-selected="false">Plans</button>
                </li>
                <li class="nav-item" role="presentation">
                    <button class="nav-link" id="icons-tab" data-bs-toggle="tab" data-bs-target="#icons" type="button" role="tab" aria-controls="icons" aria-selected="false">Icons</button>
                </li>
                <li class="nav-item" role="presentation">
                    <button class="nav-link" id="markers-tab" data-bs-toggle="tab" data-bs-target="#markers" type="button" role="tab" aria-controls="markers" aria-selected="false">Markers</button>
                </li>
            </ul>

            <div class="tab-content" id="editionTabsContent">
                <!-- Settings tab (bounds and map)-->
                <div class="tab-pane fade show active" id="settings" role="tabpanel" aria-labelledby="settings-tab">
                    <form id="settingsForm" class="row">
                        <div class="col-md-6">
                            <h4>Map limits (bounds)</h4>
                            <div class="form-group">
                                <label for="minX">X Min:</label>
                                <input type="number" class="form-control" id="minX" required>
                            </div>
                            <div class="form-group">
                                <label for="minY">Y Min:</label>
                                <input type="number" class="form-control" id="minY" required>
                            </div>
                            <div class="form-group">
                                <label for="maxX">X Max:</label>
                                <input type="number" class="form-control" id="maxX" required>
                            </div>
                            <div class="form-group">
                                <label for="maxY">Y Max:</label>
                                <input type="number" class="form-control" id="maxY" required>
                            </div>
                        </div>

                        <div class="col-md-6">
                            <h4>Map settings</h4>
                            <div class="form-group">
                                <label for="minZoom">Zoom minimum:</label>
                                <input type="number" step="0.5" class="form-control" id="minZoom" required>
                            </div>
                            <div class="form-group">
                                <label for="zoomDelta">Zoom delta:</label>
                                <input type="number" step="0.05" class="form-control" id="zoomDelta" required>
                            </div>
                            <div class="form-group">
                                <label for="zoomSnap">Zoom snap:</label>
                                <input type="number" step="0.05" class="form-control" id="zoomSnap" required>
                            </div>
                            <div class="form-group">
                                <label for="defaultLayer">Default layer:</label>
                                <select class="form-control" id="defaultLayer">
                                    <option value="">Select a plan...</option>
                                    <!-- Plans will be added here dynamically -->
                                </select>
                            </div>
                            <div class="form-group">
                                <label for="centerX">Center X:</label>
                                <input type="number" class="form-control" id="centerX" required>
                            </div>
                            <div class="form-group">
                                <label for="centerY">Center Y:</label>
                                <input type="number" class="form-control" id="centerY" required>
                            </div>
                            <div class="form-group">
                                <label for="defaultZoom">Zoom default:</label>
                                <input type="number" step="0.5" class="form-control" id="defaultZoom" required>
                            </div>
                        </div>

                        <div class="col-12 mt-3">
                            <button type="submit" class="btn btn-primary">Save</button>
                            <button type="button" id="useCurrentBounds" class="btn btn-secondary">Use Current Limits</button>
                        </div>
                    </form>
                </div>

                <!-- Plans tab -->
                <div class="tab-pane fade" id="plans" role="tabpanel" aria-labelledby="plans-tab">
                    <div class="row">
                        <div class="col-md-6">
                            <div class="d-flex justify-content-between mb-3">
                                <h4>Plans list</h4>
                                <button class="btn btn-sm btn-success" id="newPlanBtn">New Plan</button>
                            </div>

                            <div class="list-group mb-3" id="plansList">
                                <!-- Plans will be added here dynamically -->
                            </div>
                        </div>

                        <div class="col-md-6">
                            <form id="planForm" style="display: none;">
                                <h5 id="planFormTitle">Add a Plan</h5>
                                <div class="form-group">
                                    <label for="planId">ID Plan:</label>
                                    <input type="text" class="form-control" id="planId" required>
                                    <small class="form-text text-muted" id="planIdFeedback"></small>
                                </div>
                                <div class="form-group">
                                    <label for="planName">Plan name:</label>
                                    <input type="text" class="form-control" id="planName" required>
                                </div>
                                <div class="form-group">
                                    <label for="planImage">Plan image:</label>
                                    <select class="form-control" id="planImage" required>
                                        <option value="">Select a picture...</option>
                                        {% for file in plan_files %}
                                            <option value="{{ file }}">{{ file }}</option>
                                        {% endfor %}
                                    </select>
                                </div>
                                <input type="hidden" id="planAction" value="create">
                                <input type="hidden" id="originalPlanId" value="">
                                <button type="submit" class="btn btn-primary">Save</button>
                                <button type="button" id="cancelPlanBtn" class="btn btn-secondary">Cancel</button>
                                <button type="button" id="deletePlanBtn" class="btn btn-danger" style="display: none;">Delete</button>
                            </form>

                            <div id="planOrderContainer" class="mt-4">
                                <h5>Order of Plans</h5>
                                <p class="text-muted">Drag and drop to change the order</p>
                                <div class="list-group" id="plansOrderList">
                                    <!-- Plans will be added here dynamically to be reordered -->
                                </div>
                                <button type="button" id="saveOrderBtn" class="btn btn-primary mt-3">Save the Order</button>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Icons tab -->
                <div class="tab-pane fade" id="icons" role="tabpanel" aria-labelledby="icons-tab">
                    <div class="row">
                        <div class="col-md-6">
                            <div class="d-flex justify-content-between mb-3">
                                <h4>Icons list</h4>
                                <button class="btn btn-sm btn-success" id="newIconBtn">New Icon</button>
                            </div>

                            <div class="list-group mb-3" id="iconsList">
                                <!-- Icons will be added here dynamically -->
                            </div>
                        </div>

                        <div class="col-md-6">
                            <form id="iconForm" style="display: none;">
                                <h5 id="iconFormTitle">Add an Icon</h5>
                                <div class="form-group">
                                    <label for="iconName">Name of the Icone:</label>
                                    <input type="text" class="form-control" id="iconName" required>
                                    <small class="form-text text-muted" id="iconNameFeedback"></small>
                                </div>
                                <div class="form-group">
                                    <label for="iconUrl">Icon URL:</label>
                                    <select class="form-control" id="iconUrl" required>
                                        <option value="">Select an icon...</option>
                                        {% for file in marker_files %}
                                            <option value="{{ file }}">{{ file }}</option>
                                        {% endfor %}
                                    </select>
                                </div>
                                <div class="form-group">
                                    <label for="shadowUrl">Shadow URL:</label>
                                    <select class="form-control" id="shadowUrl">
                                        <option value="">No shadow</option>
                                        {% for file in marker_files %}
                                            <option value="{{ file }}">{{ file }}</option>
                                        {% endfor %}
                                    </select>
                                </div>
                                <div class="form-group">
                                    <label for="iconSize">Icon Size [width, height]:</label>
                                    <input type="text" class="form-control" id="iconSize" placeholder="Ex: [25, 41]">
                                </div>
                                <div class="form-group">
                                    <label for="iconAnchor">Anchor Icon [x, y]:</label>
                                    <input type="text" class="form-control" id="iconAnchor" placeholder="Ex: [12, 41]">
                                </div>
                                <div class="form-group">
                                    <label for="popupAnchor">Popup Anchor [x, y]:</label>
                                    <input type="text" class="form-control" id="popupAnchor" placeholder="Ex: [1, -34]">
                                </div>
                                <div class="form-group">
                                    <label for="shadowSize">Shadow Size [width, height]:</label>
                                    <input type="text" class="form-control" id="shadowSize" placeholder="Ex: [41, 41]">
                                </div>
                                <input type="hidden" id="iconAction" value="create">
                                <input type="hidden" id="originalIconName" value="">
                                <button type="submit" class="btn btn-primary">Save</button>
                                <button type="button" id="cancelIconBtn" class="btn btn-secondary">Cancel</button>
                                <button type="button" id="deleteIconBtn" class="btn btn-danger" style="display: none;">Delete</button>
                            </form>
                        </div>
                    </div>
                </div>

                <!-- Markers Tab -->
                <div class="tab-pane fade" id="markers" role="tabpanel" aria-labelledby="markers-tab">
                    <div class="row">
                        <div class="col-md-6">
                            <div class="d-flex justify-content-between mb-3">
                                <h4>Markers list</h4>
                                <button class="btn btn-sm btn-success" id="newMarkerBtn">New Marker</button>
                            </div>

                            <div class="list-group mb-3" id="markersList">
                                <!-- Markers will be added here dynamically -->
                            </div>
                        </div>

                        <div class="col-md-6">
                            <form id="markerForm" style="display: none;">
                                <h5 id="markerFormTitle">Add a Marker</h5>
                                <div class="form-group">
                                    <label for="markerId">Marker ID:</label>
                                    <input type="text" class="form-control" id="markerId" required>
                                    <small class="form-text text-muted" id="markerIdFeedback"></small>
                                </div>
                                <div class="form-group">
                                    <label for="markerType">Type:</label>
                                    <select class="form-control" id="markerType" required>
                                        <option value="marker">Marqueur</option>
                                        <option value="polygon">Polygone</option>
                                    </select>
                                </div>
                                <div class="form-group">
                                    <label for="markerBound">Associated Plan:</label>
                                    <select class="form-control" id="markerBound" required>
                                        <option value="">Select a plan...</option>
                                        <!-- Plans will be added here dynamically -->
                                    </select>
                                </div>
                                <div class="form-group marker-field">
                                    <label for="markerCoords">Coordinates [x, y]:</label>
                                    <input type="text" class="form-control" id="markerCoords" placeholder="Ex: [800, 400]" required>
                                </div>
                                <div class="form-group polygon-field" style="display: none;">
                                    <label for="polygonCoords">Polygone coordinates [[x1, y1], [x2, y2], ...]:</label>
                                    <textarea class="form-control" id="polygonCoords" rows="4" placeholder="Ex: [[800, 400], [900, 500], [700, 600]]"></textarea>
                                </div>
                                <div class="form-group marker-field">
                                    <label for="markerIcon">Icône:</label>
                                    <select class="form-control" id="markerIcon">
                                        <option value="">Default Maker</option>
                                        <!-- Icons will be added here dynamically -->
                                    </select>
                                </div>
                                <div class="form-group">
                                    <label for="markerPopup">Popup Text:</label>
                                    <textarea class="form-control" id="markerPopup" rows="2"></textarea>
                                </div>
                                <input type="hidden" id="markerAction" value="create">
                                <input type="hidden" id="originalMarkerId" value="">
                                <button type="submit" class="btn btn-primary">Save</button>
                                <button type="button" id="cancelMarkerBtn" class="btn btn-secondary">Cancel</button>
                                <button type="button" id="deleteMarkerBtn" class="btn btn-danger" style="display: none;">Delete</button>
                            </form>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
{% endblock %}

{% block script %}
<script src="{% static 'js/Sortable.min.js' %}"></script>
<script>
    // Store JSON data loaded from the server
    const mapData = {{ map_data|safe }};

    // Define static paths
    const STATIC_URL_IMG = "{% static 'img/' %}";
    const STATIC_URL_MARKERS = "{% static 'markers/' %}";
    const STATIC_URL_PLANS = "{% static 'plans/' %}";
    const STATIC_URL_JSON = "{% static 'json/' %}";

    // Global variables
    let map;
    let currentLayers = {};
    let currentMarkers = {};
    let currentPolygons = {};
    let iconsList = {};
    let drawingPolygon = false;
    let polygonPoints = [];
    let tempPolygon = null;
    let planOrder = [];

    // Initialize the card
    function initMap() {
        // Create the map with the specified parameters
        map = L.map('map', {
            crs: L.CRS.Simple,
            minZoom: mapData.map.minZoom || -5,
            zoomDelta: mapData.map.zoomDelta || 0.25,
            zoomSnap: mapData.map.zoomSnap || 0
        });

        // Configure limits
        const bounds = mapData.bounds;
        map.fitBounds(bounds);

        // Create the layers for the different plans
        currentLayers = {};
        if (mapData.plans) {
            // Retrieve the current order of plans
            planOrder = Object.keys(mapData.plans);

            for (const [planId, plan] of Object.entries(mapData.plans)) {
                currentLayers[planId] = L.layerGroup();
                L.imageOverlay(STATIC_URL_PLANS + plan.image, bounds).addTo(currentLayers[planId]);

                // Add the markers associated with this plan
                if (mapData.markers) {
                    for (const markerGroup of mapData.markers) {
                        for (const [markerId, marker] of Object.entries(markerGroup)) {
                            if (marker.bound === planId) {
                                addMarkerToMap(markerId, marker, planId);
                            }
                        }
                    }
                }
            }

            // Add the default layer to the map
            if (mapData.map.layers && currentLayers[mapData.map.layers]) {
                currentLayers[mapData.map.layers].addTo(map);
            } else if (planOrder.length > 0) {
                currentLayers[planOrder[0]].addTo(map);
            }

            // Add Layer Control
            const baseMaps = {};
            for (const planId of planOrder) {
                if (mapData.plans[planId]) {
                    baseMaps[mapData.plans[planId].name] = currentLayers[planId];
                }
            }
            L.control.layers(baseMaps).addTo(map);
        }

        // Initialize custom icons
        if (mapData.icons) {
            iconsList = mapData.icons;
        }

        // Configure the view
        if (mapData.map.xy && mapData.map.z !== undefined) {
            map.setView([mapData.map.xy[0], mapData.map.xy[1]], mapData.map.z);
        }

        // Click event to get coordinates
        map.on('click', function(e) {
            const x = Math.round(e.latlng.lat);
            const y = Math.round(e.latlng.lng);
            console.log(`[${x}, ${y}]`);

            // If we are drawing a polygon, add the point
            if (drawingPolygon) {
                polygonPoints.push([x, y]);

                // Update the temporary polygon
                if (tempPolygon) {
                    map.removeLayer(tempPolygon);
                }

                if (polygonPoints.length > 2) {
                    tempPolygon = L.polygon(polygonPoints, { color: '#ff7800' }).addTo(map);
                } else if (polygonPoints.length === 2) {
                    tempPolygon = L.polyline(polygonPoints, { color: '#ff7800' }).addTo(map);
                }

                // Update the coordinates text field
                document.getElementById('polygonCoords').value = JSON.stringify(polygonPoints);
            }
        });
    }

    // Add a marker or polygon to the map
    function addMarkerToMap(markerId, markerData, planId) {
        if (!currentLayers[planId]) return;

        if (markerData.type === "marker") {
            const markerOptions = {};

            // If an icon is specified and exists in our icon list
            if (markerData.icon && iconsList[markerData.icon]) {
                const iconConfig = iconsList[markerData.icon];
                const iconUrl = iconConfig.iconUrl.startsWith('marker-') ?
                    STATIC_URL_MARKERS + iconConfig.iconUrl :
                    STATIC_URL_IMG + iconConfig.iconUrl;
                const shadowUrl = iconConfig.shadowUrl ?
                    (iconConfig.shadowUrl.startsWith('marker-') ?
                        STATIC_URL_MARKERS + iconConfig.shadowUrl :
                        STATIC_URL_IMG + iconConfig.shadowUrl) :
                '';

                markerOptions.icon = L.icon({
                    iconUrl: iconUrl,
                    shadowUrl: shadowUrl,
                    iconSize: iconConfig.iconSize || [25, 41],
                    iconAnchor: iconConfig.iconAnchor || [12, 41],
                    popupAnchor: iconConfig.popupAnchor || [1, -34],
                    shadowSize: iconConfig.shadowSize || [41, 41]
                });
            }

            // Create and add the marker to the corresponding layer
            const marker = L.marker(markerData.xy, markerOptions)
                .bindPopup(markerData.popup || '')
                .addTo(currentLayers[planId]);

            // Store the marker so you can delete it later
            if (!currentMarkers[planId]) currentMarkers[planId] = {};
            currentMarkers[planId][markerId] = marker;

        } else if (markerData.type === "polygon") {
            // Create and add the polygon to the corresponding layer
            const polygon = L.polygon(markerData.xy, {
                color: markerData.color || '#3388ff'
            })
                .bindPopup(markerData.popup || '')
                .addTo(currentLayers[planId]);

            // Store the polygon so that it can be deleted later
            if (!currentPolygons[planId]) currentPolygons[planId] = {};
            currentPolygons[planId][markerId] = polygon;
        }
    }

    // Update the plan drop-down lists
    function updatePlansDropdowns() {
        const defaultLayer = document.getElementById('defaultLayer');
        const markerBound = document.getElementById('markerBound');

        // Clear the lists
        defaultLayer.innerHTML = '<option value="">Sélectionnez un plan...</option>';
        markerBound.innerHTML = '<option value="">Sélectionnez un plan...</option>';

        // Add plans in current order
        if (mapData.plans) {
            for (const planId of planOrder) {
                if (mapData.plans[planId]) {
                    const plan = mapData.plans[planId];

                    // Add the option to the defaultLayer dropdown
                    const optionDefault = document.createElement('option');
                    optionDefault.value = planId;
                    optionDefault.textContent = plan.name;
                    defaultLayer.appendChild(optionDefault);

                    // Add the option to the markerBound dropdown
                    const optionBound = document.createElement('option');
                    optionBound.value = planId;
                    optionBound.textContent = plan.name;
                    markerBound.appendChild(optionBound);
                }
            }
        }

        // Select the current default layer
        if (mapData.map && mapData.map.layers) {
            defaultLayer.value = mapData.map.layers;
        }
    }

    // Update the plan list in the interface
    function updatePlansList() {
        const plansList = document.getElementById('plansList');
        plansList.innerHTML = '';

        const plansOrderList = document.getElementById('plansOrderList');
        plansOrderList.innerHTML = '';

        if (mapData.plans) {
            for (const planId of planOrder) {
                if (mapData.plans[planId]) {
                    const plan = mapData.plans[planId];

                    // Create the item for the plan list
                    const listItem = document.createElement('a');
                    listItem.className = 'list-group-item list-group-item-action d-flex align-items-center';
                    listItem.setAttribute('data-plan-id', planId);

                    // Create a plan preview
                    const planPreview = document.createElement('img');
                    planPreview.src = STATIC_URL_PLANS + plan.image;
                    planPreview.className = 'plan-preview me-3';
                    planPreview.alt = plan.name;

                    const textSpan = document.createElement('span');
                    textSpan.innerHTML = `<strong>${planId}</strong>: ${plan.name}`;

                    listItem.appendChild(planPreview);
                    listItem.appendChild(textSpan);

                    // Add click event to edit the plan
                    listItem.addEventListener('click', function() {
                        editPlan(planId);
                    });

                    plansList.appendChild(listItem);

                    // Create the item for the plan order list
                    const orderItem = document.createElement('div');
                    orderItem.className = 'list-group-item d-flex align-items-center';
                    orderItem.setAttribute('data-plan-id', planId);

                    const dragHandle = document.createElement('div');
                    dragHandle.className = 'drag-handle me-3';
                    dragHandle.innerHTML = '<i class="fas fa-grip-vertical"></i>';

                    const previewContainer = document.createElement('div');
                    previewContainer.className = 'plan-preview-container';

                    const orderPreview = document.createElement('img');
                    orderPreview.src = STATIC_URL_PLANS + plan.image;
                    orderPreview.className = 'plan-preview';
                    orderPreview.alt = plan.name;

                    previewContainer.appendChild(orderPreview);

                    const orderTextSpan = document.createElement('span');
                    orderTextSpan.textContent = plan.name;

                    orderItem.appendChild(dragHandle);
                    orderItem.appendChild(previewContainer);
                    orderItem.appendChild(orderTextSpan);

                    plansOrderList.appendChild(orderItem);
                }
            }
        }

        // Initialize drag-and-drop sorting for plan order
        initSortable();
    }

    // Initialize drag and drop sorting
    function initSortable() {
        const plansOrderList = document.getElementById('plansOrderList');
        new Sortable(plansOrderList, {
            handle: '.drag-handle',
            animation: 150,
            onEnd: function(evt) {
                // Mettre à jour l'ordre des plans
                const items = plansOrderList.querySelectorAll('.list-group-item');
                planOrder = [];
                for (const item of items) {
                    planOrder.push(item.getAttribute('data-plan-id'));
                }
            }
        });
    }

    // Update the list of icons in the interface
    function updateIconsList() {
        const iconsList = document.getElementById('iconsList');
        iconsList.innerHTML = '';

        if (mapData.icons) {
            for (const [iconName, iconConfig] of Object.entries(mapData.icons)) {
                const listItem = document.createElement('a');
                listItem.className = 'list-group-item list-group-item-action d-flex justify-content-between align-items-center';
                listItem.setAttribute('data-icon-name', iconName);

                // Create an icon preview
                const iconPreview = document.createElement('img');
                iconPreview.src = STATIC_URL_MARKERS + iconConfig.iconUrl;
                iconPreview.className = 'icon-preview me-3';
                iconPreview.alt = iconName;

                const textSpan = document.createElement('span');
                textSpan.textContent = iconName;

                listItem.appendChild(iconPreview);
                listItem.appendChild(textSpan);

                // Add click event to edit icon
                listItem.addEventListener('click', function() {
                    editIcon(iconName);
                });

                iconsList.appendChild(listItem);
            }
        }
    }

    // Update the icon dropdown for markers
    function updateIconsDropdown() {
        const markerIcon = document.getElementById('markerIcon');

        // Keep only the default option
        while (markerIcon.options.length > 1) {
            markerIcon.remove(1);
        }

        // Add available icons
        if (mapData.icons) {
            for (const iconName of Object.keys(mapData.icons)) {
                const option = document.createElement('option');
                option.value = iconName;
                option.textContent = iconName;
                markerIcon.appendChild(option);
            }
        }
    }

    // Update the list of markers in the interface
    function updateMarkersList() {
        const markersList = document.getElementById('markersList');
        markersList.innerHTML = '';

        if (mapData.markers) {
            for (const markerGroup of mapData.markers) {
                for (const [markerId, marker] of Object.entries(markerGroup)) {
                    const listItem = document.createElement('a');
                    listItem.className = 'list-group-item list-group-item-action d-flex justify-content-between align-items-center';
                    listItem.setAttribute('data-marker-id', markerId);

                    // Icon type (marker or polygon)
                    const typeIcon = document.createElement('i');
                    typeIcon.className = `fas fa-${marker.type === 'marker' ? 'map-marker-alt' : 'draw-polygon'} me-2`;

                    const textSpan = document.createElement('span');
                    textSpan.innerHTML = `<strong>${markerId}</strong>: ${marker.popup || 'Sans popup'}`;

                    const boundSpan = document.createElement('small');
                    boundSpan.className = 'badge bg-info text-white ms-2';
                    boundSpan.textContent = marker.bound || 'Sans plan';

                    listItem.appendChild(typeIcon);
                    listItem.appendChild(textSpan);
                    listItem.appendChild(boundSpan);

                    // Add click event to edit marker
                    listItem.addEventListener('click', function() {
                        editMarker(markerId);
                    });

                    markersList.appendChild(listItem);
                }
            }
        }
    }

    // Edit an existing plan
    function editPlan(planId) {
        const plan = mapData.plans[planId];

        // Update the form with the current values
        document.getElementById('planId').value = planId;
        document.getElementById('planName').value = plan.name || '';
        document.getElementById('planImage').value = plan.image || '';

        // Change the action and display the form
        document.getElementById('planAction').value = 'update';
        document.getElementById('originalPlanId').value = planId;
        document.getElementById('planFormTitle').textContent = 'Modifier un Plan';
        document.getElementById('deletePlanBtn').style.display = 'inline-block';
        document.getElementById('planForm').style.display = 'block';
    }

    // Edit an existing icon
    function editIcon(iconName) {
        const iconConfig = mapData.icons[iconName];

        // Update the form with the current values
        document.getElementById('iconName').value = iconName;
        document.getElementById('iconUrl').value = iconConfig.iconUrl || '';
        document.getElementById('shadowUrl').value = iconConfig.shadowUrl || '';
        document.getElementById('iconSize').value = iconConfig.iconSize ? JSON.stringify(iconConfig.iconSize) : '';
        document.getElementById('iconAnchor').value = iconConfig.iconAnchor ? JSON.stringify(iconConfig.iconAnchor) : '';
        document.getElementById('popupAnchor').value = iconConfig.popupAnchor ? JSON.stringify(iconConfig.popupAnchor) : '';
        document.getElementById('shadowSize').value = iconConfig.shadowSize ? JSON.stringify(iconConfig.shadowSize) : '';

        // Change the action and display the form
        document.getElementById('iconAction').value = 'update';
        document.getElementById('originalIconName').value = iconName;
        document.getElementById('iconFormTitle').textContent = 'Modifier une Icône';
        document.getElementById('deleteIconBtn').style.display = 'inline-block';
        document.getElementById('iconForm').style.display = 'block';
    }

    // Find and edit an existing marker
    function editMarker(markerId) {
        let markerData = null;
        let markerGroupIndex = -1;

        // Search marker in groups
        for (let i = 0; i < mapData.markers.length; i++) {
            if (markerId in mapData.markers[i]) {
                markerData = mapData.markers[i][markerId];
                markerGroupIndex = i;
                break;
            }
        }

        if (!markerData) return;

        // Update the form with the current values
        document.getElementById('markerId').value = markerId;
        document.getElementById('markerType').value = markerData.type;
        document.getElementById('markerBound').value = markerData.bound || '';

        // Show/hide appropriate fields depending on the type
        toggleMarkerFields(markerData.type);

        if (markerData.type === 'marker') {
            document.getElementById('markerCoords').value = JSON.stringify(markerData.xy);
            document.getElementById('markerIcon').value = markerData.icon || '';
        } else if (markerData.type === 'polygon') {
            document.getElementById('polygonCoords').value = JSON.stringify(markerData.xy);
        }

        document.getElementById('markerPopup').value = markerData.popup || '';

        // Change the action and display the form
        document.getElementById('markerAction').value = 'update';
        document.getElementById('originalMarkerId').value = markerId;
        document.getElementById('markerFormTitle').textContent = 'Modifier un Marqueur';
        document.getElementById('deleteMarkerBtn').style.display = 'inline-block';
        document.getElementById('markerForm').style.display = 'block';
    }

    // Toggle field display based on marker type
    function toggleMarkerFields(type) {
        const markerFields = document.querySelectorAll('.marker-field');
        const polygonFields = document.querySelectorAll('.polygon-field');

        if (type === 'marker') {
            markerFields.forEach(field => field.style.display = 'block');
            polygonFields.forEach(field => field.style.display = 'none');
        } else if (type === 'polygon') {
            markerFields.forEach(field => field.style.display = 'none');
            polygonFields.forEach(field => field.style.display = 'block');
        }
    }

    // Save changes to the server
    async function saveToServer(data) {
        try {
            const response = await fetch(window.location.href, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'X-Requested-With': 'XMLHttpRequest',
                    'X-CSRFToken': getCookie('csrftoken')
                },
                body: JSON.stringify(data)
            });

            const result = await response.json();

            if (result.status === 'success') {
                return true;
            } else {
                alert('Error while saving: ' + (result.message || 'Erreur inconnue'));
                return false;
            }
        } catch (error) {
            alert('Error while saving: ' + error.message);
            return false;
        }
    }

    // Get the value of a cookie (for CSRF)
    function getCookie(name) {
        let cookieValue = null;
        if (document.cookie && document.cookie !== '') {
            const cookies = document.cookie.split(';');
            for (let i = 0; i < cookies.length; i++) {
                const cookie = cookies[i].trim();
                if (cookie.substring(0, name.length + 1) === (name + '=')) {
                    cookieValue = decodeURIComponent(cookie.substring(name.length + 1));
                    break;
                }
            }
        }
        return cookieValue;
    }

    // Checks if the icon name is unique
    function isIconNameUnique(name, originalName) {
        // Si c'est une mise à jour et que le nom n'a pas changé, c'est valide
        if (name === originalName) return true;

        // Vérifier si le nom existe déjà dans les icônes
        return !(mapData.icons && mapData.icons.hasOwnProperty(name));
    }

    // Checks if the plan ID is unique
    function isPlanIdUnique(id, originalId) {
        // Si c'est une mise à jour et que l'ID n'a pas changé, c'est valide
        if (id === originalId) return true;

        // Check if ID already exists in plans
        return !(mapData.plans && mapData.plans.hasOwnProperty(id));
    }

    // Checks if the marker ID is unique
    function isMarkerIdUnique(id, originalId) {
        // Si c'est une mise à jour et que l'ID n'a pas changé, c'est valide
        if (id === originalId) return true;

        // Vérifier si l'ID existe déjà dans les marqueurs
        for (const markerGroup of mapData.markers) {
            if (id in markerGroup && id !== originalId) {
                return false;
            }
        }
        return true;
    }

    // Initialize the application when the DOM is loaded
    document.addEventListener('DOMContentLoaded', function() {
        // Initialiser la carte
        initMap();

        // Update the lists
        updatePlansList();
        updateIconsList();
        updateIconsDropdown();
        updatePlansDropdowns();
        updateMarkersList();

        // Fill in the settings form with the current values
        document.getElementById('minX').value = mapData.bounds[0][0];
        document.getElementById('minY').value = mapData.bounds[0][1];
        document.getElementById('maxX').value = mapData.bounds[1][0];
        document.getElementById('maxY').value = mapData.bounds[1][1];

        document.getElementById('minZoom').value = mapData.map.minZoom || -5;
        document.getElementById('zoomDelta').value = mapData.map.zoomDelta || 0.25;
        document.getElementById('zoomSnap').value = mapData.map.zoomSnap || 0;
        document.getElementById('defaultLayer').value = mapData.map.layers || '';
        document.getElementById('centerX').value = mapData.map.xy ? mapData.map.xy[0] : 0;
        document.getElementById('centerY').value = mapData.map.xy ? mapData.map.xy[1] : 0;
        document.getElementById('defaultZoom').value = mapData.map.z || 0;

        // Event to use current map limits
        document.getElementById('useCurrentBounds').addEventListener('click', function() {
            const bounds = map.getBounds();
            const sw = bounds.getSouthWest();
            const ne = bounds.getNorthEast();

            document.getElementById('minX').value = Math.round(sw.lat);
            document.getElementById('minY').value = Math.round(sw.lng);
            document.getElementById('maxX').value = Math.round(ne.lat);
            document.getElementById('maxY').value = Math.round(ne.lng);

            const center = map.getCenter();
            document.getElementById('centerX').value = Math.round(center.lat);
            document.getElementById('centerY').value = Math.round(center.lng);
            document.getElementById('defaultZoom').value = map.getZoom();
        });

        // Parameters form submission event
        document.getElementById('settingsForm').addEventListener('submit', async function(e) {
            e.preventDefault();

            const minX = parseInt(document.getElementById('minX').value);
            const minY = parseInt(document.getElementById('minY').value);
            const maxX = parseInt(document.getElementById('maxX').value);
            const maxY = parseInt(document.getElementById('maxY').value);

            const minZoom = parseFloat(document.getElementById('minZoom').value);
            const zoomDelta = parseFloat(document.getElementById('zoomDelta').value);
            const zoomSnap = parseFloat(document.getElementById('zoomSnap').value);
            const defaultLayer = document.getElementById('defaultLayer').value;
            const centerX = parseInt(document.getElementById('centerX').value);
            const centerY = parseInt(document.getElementById('centerY').value);
            const defaultZoom = parseFloat(document.getElementById('defaultZoom').value);

            // Update local data
            mapData.bounds = [[minX, minY], [maxX, maxY]];
            mapData.map = {
                minZoom: minZoom,
                zoomDelta: zoomDelta,
                zoomSnap: zoomSnap,
                layers: defaultLayer,
                xy: [centerX, centerY],
                z: defaultZoom
            };

            // Send data to the server
            const success = await saveToServer({
                action: 'update_bounds_map',
                bounds: mapData.bounds,
                map: mapData.map
            });

            if (success) {
                // Recharger la page pour appliquer les changements
                alert('Settings updated successfully! The page will be reloaded.');
                window.location.reload();
            }
        });

        // Events for the plans form
        document.getElementById('newPlanBtn').addEventListener('click', function() {
            // Reset the form
            document.getElementById('planForm').reset();
            document.getElementById('planAction').value = 'create';
            document.getElementById('originalPlanId').value = '';
            document.getElementById('planFormTitle').textContent = 'Ajouter un Plan';
            document.getElementById('deletePlanBtn').style.display = 'none';
            document.getElementById('planForm').style.display = 'block';
        });

        document.getElementById('cancelPlanBtn').addEventListener('click', function() {
            document.getElementById('planForm').style.display = 'none';
        });

        document.getElementById('planForm').addEventListener('submit', async function(e) {
            e.preventDefault();

            // Retrieve form values
            const planId = document.getElementById('planId').value;
            const planName = document.getElementById('planName').value;
            const planImage = document.getElementById('planImage').value;
            const originalPlanId = document.getElementById('originalPlanId').value;

            // Check that the ID is unique
            if (!isPlanIdUnique(planId, originalPlanId)) {
                alert('This plan ID already exists. Please choose another one.');
                return;
            }

            // Prepare the plan data
            const planData = {
                name: planName,
                image: planImage
            };

            // Determine the action (create or update)
            const planAction = document.getElementById('planAction').value;

            // Update local data
            if (!mapData.plans) mapData.plans = {};

            // If this is an update and the ID has changed, delete the old entry
            if (planAction === 'update' && originalPlanId !== planId) {
                delete mapData.plans[originalPlanId];

                // Update the order of the plans
                const index = planOrder.indexOf(originalPlanId);
                if (index !== -1) {
                    planOrder.splice(index, 1, planId);
                }
            } else if (planAction === 'create') {
                // Add the new plan to the end of the order
                planOrder.push(planId);
            }

            mapData.plans[planId] = planData;

            // Send data to the server
            const success = await saveToServer({
                action: 'crud_plan',
                plan_action: planAction,
                plan_id: planId,
                plan_data: planData,
                original_plan_id: originalPlanId
            });

            if (success) {
                // Update the interface
                updatePlansList();
                updatePlansDropdowns();
                document.getElementById('planForm').style.display = 'none';
                alert(`Plan ${planAction === 'create' ? 'ajouté' : 'mis à jour'} avec succès!`);
            }
        });

        document.getElementById('deletePlanBtn').addEventListener('click', async function() {
            const planId = document.getElementById('originalPlanId').value;

            if (confirm(`Êtes-vous sûr de vouloir supprimer le plan "${planId}" ?`)) {
                // Delete local data plan
                if (mapData.plans && mapData.plans[planId]) {
                    delete mapData.plans[planId];

                    // Update the order of the plans
                    const index = planOrder.indexOf(planId);
                    if (index !== -1) {
                        planOrder.splice(index, 1);
                    }
                }

                // Send the deletion request to the server
                const success = await saveToServer({
                    action: 'crud_plan',
                    plan_action: 'delete',
                    plan_id: planId
                });

                if (success) {
                    // Update the interface
                    updatePlansList();
                    updatePlansDropdowns();
                    document.getElementById('planForm').style.display = 'none';
                    alert('Plan successfully deleted!');
                }
            }
        });

        // Save the order of the shots
        document.getElementById('saveOrderBtn').addEventListener('click', async function() {
            // Send the reorder request to the server
            const success = await saveToServer({
                action: 'crud_plan',
                plan_action: 'reorder',
                new_order: planOrder
            });

            if (success) {
                alert('Plan order successfully updated!');
            }
        });

        // Events for the icon form
        document.getElementById('newIconBtn').addEventListener('click', function() {
            // Réinitialiser le formulaire
            document.getElementById('iconForm').reset();
            document.getElementById('iconAction').value = 'create';
            document.getElementById('originalIconName').value = '';
            document.getElementById('iconFormTitle').textContent = 'Ajouter une Icône';
            document.getElementById('deleteIconBtn').style.display = 'none';
            document.getElementById('iconForm').style.display = 'block';
        });

        document.getElementById('cancelIconBtn').addEventListener('click', function() {
            document.getElementById('iconForm').style.display = 'none';
        });

        document.getElementById('iconForm').addEventListener('submit', async function(e) {
            e.preventDefault();

            // Retrieve form values
            const iconName = document.getElementById('iconName').value;
            const iconUrl = document.getElementById('iconUrl').value;
            const shadowUrl = document.getElementById('shadowUrl').value;
            const iconSize = document.getElementById('iconSize').value;
            const iconAnchor = document.getElementById('iconAnchor').value;
            const popupAnchor = document.getElementById('popupAnchor').value;
            const shadowSize = document.getElementById('shadowSize').value;

            // Check that the name is unique
            const originalIconName = document.getElementById('originalIconName').value;
            const isUnique = isIconNameUnique(iconName, originalIconName);

            if (!isUnique) {
                document.getElementById('iconNameFeedback').textContent = 'Ce nom d\'icône existe déjà. Veuillez en choisir un autre.';
                document.getElementById('iconNameFeedback').style.color = 'red';
                return;
            } else {
                document.getElementById('iconNameFeedback').textContent = '';
            }

            // Prepare the icon data
            const iconData = {
                iconUrl: iconUrl
            };

            if (shadowUrl) iconData.shadowUrl = shadowUrl;
            if (iconSize) {
                try {
                    iconData.iconSize = JSON.parse(iconSize);
                } catch (error) {
                    alert('Invalid format for icon size. Use the format [largeur, hauteur]');
                    return;
                }
            }
            if (iconAnchor) {
                try {
                    iconData.iconAnchor = JSON.parse(iconAnchor);
                } catch (error) {
                    alert('Invalid format for icon anchor. Use the format [x, y]');
                    return;
                }
            }
            if (popupAnchor) {
                try {
                    iconData.popupAnchor = JSON.parse(popupAnchor);
                } catch (error) {
                    alert('Invalid format for popup anchor. Use the format [x, y]');
                    return;
                }
            }
            if (shadowSize) {
                try {
                    iconData.shadowSize = JSON.parse(shadowSize);
                } catch (error) {
                    alert('Invalid format for shadow size. Use the format [largeur, hauteur]');
                    return;
                }
            }

            // Determine the action (create or update)
            const iconAction = document.getElementById('iconAction').value;

            // Update local data
            if (!mapData.icons) mapData.icons = {};

            // If this is an update and the name has changed, delete the old entry
            if (iconAction === 'update' && originalIconName !== iconName) {
                delete mapData.icons[originalIconName];
            }

            mapData.icons[iconName] = iconData;

            // Send data to the server
            const success = await saveToServer({
                action: 'crud_icon',
                icon_action: iconAction,
                icon_name: iconName,
                icon_data: iconData,
                original_icon_name: originalIconName
            });

            if (success) {
                // Update the interface
                updateIconsList();
                updateIconsDropdown();
                document.getElementById('iconForm').style.display = 'none';
                alert(`Icône ${iconAction === 'create' ? 'ajoutée' : 'mise à jour'} avec succès!`);
            }
        });

        // Add real-time validation for icon name
        document.getElementById('iconName').addEventListener('input', function() {
            const iconName = this.value;
            const originalIconName = document.getElementById('originalIconName').value;
            const isUnique = isIconNameUnique(iconName, originalIconName);

            if (!isUnique) {
                document.getElementById('iconNameFeedback').textContent = 'Ce nom d\'icône existe déjà. Veuillez en choisir un autre.';
                document.getElementById('iconNameFeedback').style.color = 'red';
            } else {
                document.getElementById('iconNameFeedback').textContent = 'Nom d\'icône valide.';
                document.getElementById('iconNameFeedback').style.color = 'green';
            }
        });

        // Add real-time validation for plan ID
        document.getElementById('planId').addEventListener('input', function() {
            const planId = this.value;
            const originalPlanId = document.getElementById('originalPlanId').value;
            const isUnique = isPlanIdUnique(planId, originalPlanId);
            const feedbackElement = document.getElementById('planIdFeedback');

            if (!isUnique) {
                feedbackElement.textContent = 'Cet ID de plan existe déjà. Veuillez en choisir un autre.';
                feedbackElement.style.color = 'red';
            } else {
                feedbackElement.textContent = 'ID de plan valide.';
                feedbackElement.style.color = 'green';
            }
        });

        // Add real-time validation for marker ID
        document.getElementById('markerId').addEventListener('input', function() {
            const markerId = this.value;
            const originalMarkerId = document.getElementById('originalMarkerId').value;
            const isUnique = isMarkerIdUnique(markerId, originalMarkerId);
            const feedbackElement = document.getElementById('markerIdFeedback');

            if (!isUnique) {
                feedbackElement.textContent = 'Cet ID de marqueur existe déjà. Veuillez en choisir un autre.';
                feedbackElement.style.color = 'red';
            } else {
                feedbackElement.textContent = 'ID de marqueur valide.';
                feedbackElement.style.color = 'green';
            }
        });

        document.getElementById('deleteIconBtn').addEventListener('click', async function() {
            const iconName = document.getElementById('originalIconName').value;

            if (confirm(`Are you sure you want to delete the icon "${iconName}" ?`)) {
                // Remove local data icon
                if (mapData.icons && mapData.icons[iconName]) {
                    delete mapData.icons[iconName];
                }

                // Send the deletion request to the server
                const success = await saveToServer({
                    action: 'crud_icon',
                    icon_action: 'delete',
                    icon_name: iconName
                });

                if (success) {
                    // Update the interface
                    updateIconsList();
                    updateIconsDropdown();
                    document.getElementById('iconForm').style.display = 'none';
                    alert('Icon successfully deleted!');
                }
            }
        });

        // Events for the marker form
        document.getElementById('newMarkerBtn').addEventListener('click', function() {
            // Reset the form
            document.getElementById('markerForm').reset();
            document.getElementById('markerAction').value = 'create';
            document.getElementById('originalMarkerId').value = '';
            document.getElementById('markerFormTitle').textContent = 'Ajouter un Marqueur';
            document.getElementById('deleteMarkerBtn').style.display = 'none';
            toggleMarkerFields('marker'); // Par défaut, afficher les champs pour un marqueur
            document.getElementById('markerForm').style.display = 'block';
        });

        document.getElementById('cancelMarkerBtn').addEventListener('click', function() {
            document.getElementById('markerForm').style.display = 'none';
            drawingPolygon = false;
            polygonPoints = [];
            if (tempPolygon) {
                map.removeLayer(tempPolygon);
                tempPolygon = null;
            }
        });

        document.getElementById('markerType').addEventListener('change', function() {
            toggleMarkerFields(this.value);
        });

        // Button to enable/disable polygon drawing mode
        document.getElementById('polygonCoords').addEventListener('focus', function() {
            if (!drawingPolygon) {
                drawingPolygon = true;
                polygonPoints = [];
                alert('Polygon drawing mode is enabled. Click on the map to add points. Click Save when finished.');
            }
        });

        document.getElementById('markerForm').addEventListener('submit', async function(e) {
            e.preventDefault();

            // Retrieve form values
            const markerId = document.getElementById('markerId').value;
            const markerType = document.getElementById('markerType').value;
            const markerBound = document.getElementById('markerBound').value;
            const originalMarkerId = document.getElementById('originalMarkerId').value;

            // Check that the ID is unique
            if (!isMarkerIdUnique(markerId, originalMarkerId)) {
                alert('This marker ID already exists. Please choose another one..');
                return;
            }

            if (!markerBound) {
                alert('You must select an associated plan for this marker.');
                return;
            }

            if (!markerBound) {
                alert('You must select an associated plan for this marker.');
                return;
            }

            // Prepare marker data
            const markerData = {
                type: markerType,
                bound: markerBound
            };

            if (markerType === 'marker') {
                try {
                    markerData.xy = JSON.parse(document.getElementById('markerCoords').value);
                } catch (error) {
                    alert('Invalid format for coordinates. Use the format [x, y]');
                    return;
                }

                const iconValue = document.getElementById('markerIcon').value;
                if (iconValue) markerData.icon = iconValue;

            } else if (markerType === 'polygon') {
                try {
                    markerData.xy = JSON.parse(document.getElementById('polygonCoords').value);
                } catch (error) {
                    alert('Invalid format for polygon coordinates. Use the format [[x1, y1], [x2, y2], ...]');
                    return;
                }
            }

            const popupValue = document.getElementById('markerPopup').value;
            if (popupValue) markerData.popup = popupValue;

            // Determine the action (create or update)
            const markerAction = document.getElementById('markerAction').value;

            // Find the marker index if it is an update
            let markerGroupIndex = -1;
            if (markerAction === 'update') {
                for (let i = 0; i < mapData.markers.length; i++) {
                    if (originalMarkerId in mapData.markers[i]) {
                        markerGroupIndex = i;
                        break;
                    }
                }
            }

            // If this is an update, remove the existing marker from the map
            if (markerAction === 'update') {
                // Delete from layer
                const oldBound = markerGroupIndex !== -1 ? mapData.markers[markerGroupIndex][originalMarkerId].bound : null;

                if (oldBound && currentMarkers[oldBound] && currentMarkers[oldBound][originalMarkerId]) {
                    map.removeLayer(currentMarkers[oldBound][originalMarkerId]);
                    delete currentMarkers[oldBound][originalMarkerId];
                }

                if (oldBound && currentPolygons[oldBound] && currentPolygons[oldBound][originalMarkerId]) {
                    map.removeLayer(currentPolygons[oldBound][originalMarkerId]);
                    delete currentPolygons[oldBound][originalMarkerId];
                }
            }

            // Update local data
            if (!mapData.markers) mapData.markers = [];

            // If this is an update, update the existing marker
            if (markerAction === 'update' && markerGroupIndex !== -1) {
                // Si l'ID a changé, supprimer l'ancienne entrée
                if (originalMarkerId !== markerId) {
                    delete mapData.markers[markerGroupIndex][originalMarkerId];
                }
                mapData.markers[markerGroupIndex][markerId] = markerData;
            } else {
                // Créer un nouveau groupe pour ce marqueur
                const newMarker = {};
                newMarker[markerId] = markerData;
                mapData.markers.push(newMarker);
            }

            // Add the new marker to the map
            if (currentLayers[markerBound]) {
                addMarkerToMap(markerId, markerData, markerBound);
            }

            // Send data to the server
            const success = await saveToServer({
                action: 'crud_marker',
                marker_action: markerAction,
                marker_id: markerId,
                marker_data: markerData,
                original_marker_id: originalMarkerId
            });

            if (success) {
                // Update the interface
                updateMarkersList();
                document.getElementById('markerForm').style.display = 'none';
                alert(`Marqueur ${markerAction === 'create' ? 'add' : 'update'} with success!`);

                // Reset polygon drawing mode
                drawingPolygon = false;
                polygonPoints = [];
                if (tempPolygon) {
                    map.removeLayer(tempPolygon);
                    tempPolygon = null;
                }
            }
        });

        document.getElementById('deleteMarkerBtn').addEventListener('click', async function() {
            const markerId = document.getElementById('originalMarkerId').value;

            if (confirm(`Êtes-vous sûr de vouloir supprimer le marqueur "${markerId}" ?`)) {
                // Find the marker
                let markerData = null;
                let markerGroupIndex = -1;

                for (let i = 0; i < mapData.markers.length; i++) {
                    if (markerId in mapData.markers[i]) {
                        markerData = mapData.markers[i][markerId];
                        markerGroupIndex = i;
                        break;
                    }
                }

                if (markerData && markerData.bound) {
                    // Remove the marker from the map
                    if (currentMarkers[markerData.bound] && currentMarkers[markerData.bound][markerId]) {
                        map.removeLayer(currentMarkers[markerData.bound][markerId]);
                        delete currentMarkers[markerData.bound][markerId];
                    }

                    if (currentPolygons[markerData.bound] && currentPolygons[markerData.bound][markerId]) {
                        map.removeLayer(currentPolygons[markerData.bound][markerId]);
                        delete currentPolygons[markerData.bound][markerId];
                    }
                }

                // Remove marker from local data
                if (markerGroupIndex !== -1) {
                    delete mapData.markers[markerGroupIndex][markerId];

                    // If the group is empty, delete it completely
                    if (Object.keys(mapData.markers[markerGroupIndex]).length === 0) {
                        mapData.markers.splice(markerGroupIndex, 1);
                    }
                }

                // Send the deletion request to the server
                const success = await saveToServer({
                    action: 'crud_marker',
                    marker_action: 'delete',
                    marker_id: markerId
                });

                if (success) {
                    // Update the interface
                    updateMarkersList();
                    document.getElementById('markerForm').style.display = 'none';
                    alert('Marker successfully removed!');
                }
            }
        });
    });
</script>
{% endblock %}